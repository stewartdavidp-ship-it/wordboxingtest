<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="version" content="1.0.9">
    <title>Word Boxing ðŸ¥Š</title>
    <!-- Version 1.0.9 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ¥Š</text></svg>">
    
    <!-- PWA Support -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#c41e3a">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Word Boxing">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --red-corner: #c41e3a;
            --red-dark: #8b1528;
            --blue-corner: #1e4ec4;
            --blue-dark: #152d8b;
            --gold: #ffd700;
            --dark: #1a1a2e;
            --darker: #12121f;
            --light: #eee;
            --success: #2ecc71;
            --error: #e74c3c;
            
            /* Dark mode (default) */
            --bg-primary: #12121f;
            --bg-secondary: #1a1a2e;
            --bg-card: #252540;
            --text-primary: #eee;
            --text-secondary: #aaa;
            --border-color: #333;
            --input-bg: #1a1a2e;
            --key-bg: #444;
            --key-hover: #555;
            --key-used: #2a2a2a;
        }

        [data-theme="light"] {
            --bg-primary: #f5f5f7;
            --bg-secondary: #ffffff;
            --bg-card: #ffffff;
            --text-primary: #1a1a2e;
            --text-secondary: #666;
            --border-color: #ddd;
            --input-bg: #ffffff;
            --key-bg: #e0e0e0;
            --key-hover: #d0d0d0;
            --key-used: #f0f0f0;
            --dark: #e8e8f0;
            --darker: #f5f5f7;
            --light: #1a1a2e;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            padding-top: calc(env(safe-area-inset-top, 0px) + 45px);
            transition: background 0.3s, color 0.3s;
        }

        /* Theme Toggle */
        /* Hamburger Menu Button */
        .menu-btn {
            position: fixed;
            top: calc(env(safe-area-inset-top, 0px) + 10px);
            right: calc(env(safe-area-inset-right, 0px) + 10px);
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1.4rem;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .menu-btn:hover {
            transform: scale(1.05);
            background: var(--gold);
            color: #000;
        }

        .menu-btn svg {
            width: 22px;
            height: 22px;
            stroke: currentColor;
            stroke-width: 2;
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1001;
            align-items: flex-start;
            justify-content: flex-end;
            padding: 60px 10px 10px;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 20px;
            width: 280px;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
            border: 1px solid var(--gold);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255,215,0,0.3);
        }

        .settings-header h3 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.3rem;
            color: var(--gold);
            margin: 0;
        }

        .settings-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        .settings-close:hover {
            color: var(--gold);
        }

        .settings-section {
            margin-bottom: 20px;
        }

        .settings-section-title {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 10px;
        }

        .settings-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .settings-item:last-child {
            border-bottom: none;
        }

        .settings-item-label {
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .settings-item-desc {
            font-size: 0.8rem;
            color: #666;
            margin-top: 2px;
        }

        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: #333;
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: var(--gold);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        /* Select Dropdown for Settings */
        .settings-select {
            background: var(--bg-secondary);
            border: 1px solid #444;
            border-radius: 6px;
            color: var(--text-primary);
            padding: 6px 10px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .settings-select:focus {
            outline: none;
            border-color: var(--gold);
        }

        /* Menu Button Items */
        .settings-btn {
            display: block;
            width: 100%;
            padding: 12px 15px;
            background: rgba(255,255,255,0.05);
            border: none;
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            text-align: left;
            cursor: pointer;
            margin-bottom: 8px;
            transition: all 0.2s;
        }

        .settings-btn:hover {
            background: rgba(255,215,0,0.15);
            color: var(--gold);
        }

        .settings-btn span {
            margin-right: 10px;
        }

        .settings-version {
            text-align: center;
            color: #555;
            font-size: 0.8rem;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.05);
        }

        /* About Modal */
        .about-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1002;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .about-modal.active {
            display: flex;
        }

        .about-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 100%;
            text-align: center;
            border: 1px solid var(--gold);
        }

        .about-content h2 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            margin-bottom: 10px;
        }

        .about-content h2 .red { color: var(--red-corner); }
        .about-content h2 .blue { color: var(--blue-corner); }

        .about-tagline {
            color: var(--gold);
            font-style: italic;
            margin-bottom: 20px;
        }

        .about-text {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 15px;
            font-size: 0.95rem;
        }

        .about-credits {
            color: #888;
            font-size: 0.85rem;
            margin-top: 20px;
        }

        /* Game Overview Modal */
        .overview-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 1002;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-y: auto;
        }

        .overview-modal.active {
            display: flex;
        }

        .overview-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 25px;
            max-width: 450px;
            width: 100%;
            border: 1px solid var(--gold);
            max-height: 90vh;
            overflow-y: auto;
        }

        .overview-content h2 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 20px;
        }

        .overview-section {
            margin-bottom: 18px;
        }

        .overview-section h3 {
            color: var(--gold);
            font-size: 1rem;
            margin-bottom: 8px;
        }

        .overview-section p, .overview-section ul {
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .overview-section ul {
            padding-left: 20px;
            margin: 0;
        }

        .overview-section li {
            margin-bottom: 5px;
        }

        .overview-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 20px 0;
            padding: 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
        }

        .overview-checkbox input {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .overview-checkbox label {
            color: #aaa;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* Interactive Tutorial System */
        .tutorial-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2000;
        }

        .tutorial-overlay.active {
            display: block;
        }

        .tutorial-highlight {
            position: absolute;
            box-shadow: 0 0 0 4px var(--gold), 0 0 20px rgba(255, 215, 0, 0.5);
            border-radius: 8px;
            z-index: 2001;
            animation: tutorialPulse 2s ease infinite;
            pointer-events: none;
        }

        @keyframes tutorialPulse {
            0%, 100% { box-shadow: 0 0 0 4px var(--gold), 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 0 6px var(--gold), 0 0 30px rgba(255, 215, 0, 0.7); }
        }

        /* Tutorial tooltip - MUST use explicit colors, not theme variables */
        .tutorial-tooltip,
        [data-theme="light"] .tutorial-tooltip {
            position: absolute;
            background: #1a1a2e !important;
            border: 2px solid #ffd700 !important;
            border-radius: 12px;
            padding: 20px;
            max-width: 320px;
            z-index: 2002;
            animation: fadeIn 0.3s ease;
        }

        /* Title - gold */
        #tutorial-title,
        .tutorial-tooltip .tutorial-title,
        [data-theme="light"] #tutorial-title,
        [data-theme="light"] .tutorial-tooltip .tutorial-title {
            color: #ffd700 !important;
            -webkit-text-fill-color: #ffd700 !important;
            margin-bottom: 10px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
        }

        /* Description - white */
        #tutorial-description,
        .tutorial-tooltip .tutorial-description,
        [data-theme="light"] #tutorial-description,
        [data-theme="light"] .tutorial-tooltip .tutorial-description {
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            font-size: 0.95rem;
            line-height: 1.5;
            margin-bottom: 15px;
            white-space: pre-line;
        }

        /* Step indicator - gray */
        #tutorial-step-indicator,
        .tutorial-tooltip .tutorial-step-indicator,
        [data-theme="light"] #tutorial-step-indicator,
        [data-theme="light"] .tutorial-tooltip .tutorial-step-indicator {
            color: #cccccc !important;
            -webkit-text-fill-color: #cccccc !important;
            font-size: 0.85rem;
            margin-bottom: 8px;
        }

        .tutorial-tooltip-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border: 10px solid transparent;
        }

        .tutorial-tooltip-arrow.top {
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            border-top-color: var(--gold);
        }

        .tutorial-tooltip-arrow.bottom {
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            border-bottom-color: var(--gold);
        }

        .tutorial-tooltip-arrow.left {
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            border-left-color: var(--gold);
        }

        .tutorial-tooltip-arrow.right {
            left: -20px;
            top: 50%;
            transform: translateY(-50%);
            border-right-color: var(--gold);
        }

        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .tutorial-nav button {
            padding: 8px 16px;
            border-radius: 6px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tutorial-nav .tutorial-skip {
            background: transparent;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
        }

        .tutorial-nav .tutorial-skip:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        .tutorial-nav .tutorial-next {
            background: var(--gold);
            border: none;
            color: #000;
            font-weight: 600;
        }

        .tutorial-nav .tutorial-next:hover {
            transform: scale(1.05);
        }

        .tutorial-progress {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-top: 15px;
        }

        .tutorial-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: all 0.3s;
        }

        .tutorial-dot.active {
            background: var(--gold);
            transform: scale(1.2);
        }

        .tutorial-dot.completed {
            background: var(--success);
        }

        /* Tutorial Prompt Modal (v1.0.0) */
        .tutorial-prompt-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 3000;
            justify-content: center;
            align-items: center;
        }

        .tutorial-prompt-overlay.active {
            display: flex;
        }

        .tutorial-prompt-modal {
            background: var(--bg-card);
            border: 2px solid var(--gold);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            animation: fadeIn 0.3s ease;
        }

        .tutorial-prompt-modal h2 {
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        .tutorial-prompt-modal p {
            color: var(--text-primary);
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 25px;
        }

        .tutorial-prompt-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .tutorial-prompt-buttons button {
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tutorial-prompt-skip {
            background: transparent;
            border: 1px solid var(--text-secondary);
            color: var(--text-secondary);
        }

        .tutorial-prompt-skip:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        .tutorial-prompt-start {
            background: var(--gold);
            border: none;
            color: #000;
            font-weight: 600;
        }

        .tutorial-prompt-start:hover {
            transform: scale(1.05);
        }

        h1 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            text-align: center;
            width: 100%;
        }

        h1 .red { color: var(--red-corner); }
        h1 .blue { color: var(--blue-corner); }

        .container {
            width: 100%;
            max-width: 400px;
            padding: 0 5px;
        }

        /* Phases */
        .phase {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .phase.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Loading Spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            border-top-color: var(--gold);
            animation: spin 0.8s linear infinite;
        }

        .loading-spinner.large {
            width: 40px;
            height: 40px;
            border-width: 4px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Loading overlay for buttons */
        .btn.loading {
            position: relative;
            color: transparent !important;
            pointer-events: none;
        }

        .btn.loading::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            top: 50%;
            left: 50%;
            margin-left: -10px;
            margin-top: -10px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 0.8s linear infinite;
        }

        /* Victory celebration */
        @keyframes celebrate {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(-5deg); }
            75% { transform: scale(1.1) rotate(5deg); }
        }

        .celebrate {
            animation: celebrate 0.6s ease infinite;
        }

        /* Bounce in animation */
        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        .bounce-in {
            animation: bounceIn 0.5s ease;
        }

        /* Full-screen loading overlay */
        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 3000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }

        .loading-overlay.active {
            display: flex;
        }

        .loading-overlay .loading-spinner {
            width: 50px;
            height: 50px;
            border-width: 5px;
        }

        .loading-overlay .loading-text {
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        /* Inline loading states */
        .inline-loading {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: var(--gold);
            font-size: 0.9rem;
        }

        .inline-loading .loading-spinner {
            width: 16px;
            height: 16px;
            border-width: 2px;
        }

        /* Skeleton loading for lists */
        .skeleton {
            background: linear-gradient(90deg,
                rgba(255, 215, 0, 0.1) 25%,
                rgba(255, 215, 0, 0.2) 50%,
                rgba(255, 215, 0, 0.1) 75%);
            background-size: 200% 100%;
            animation: skeleton-shimmer 1.5s infinite;
            border-radius: 4px;
        }

        @keyframes skeleton-shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .skeleton-row {
            height: 40px;
            margin-bottom: 8px;
        }

        .skeleton-text {
            height: 16px;
            width: 60%;
        }

        /* Pulse glow for attention */
        @keyframes pulseGlow {
            0%, 100% {
                box-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
            }
            50% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.4);
            }
        }

        .pulse-glow {
            animation: pulseGlow 1.5s ease infinite;
        }

        /* Opponent disconnect banner */
        .disconnect-banner {
            display: none;
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            z-index: 1500;
            box-shadow: 0 4px 20px rgba(239, 68, 68, 0.4);
            animation: slideDown 0.3s ease;
        }

        .disconnect-banner.active {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .disconnect-banner .countdown {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }

        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        /* Reconnecting indicator */
        .reconnecting-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2500;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }

        .reconnecting-overlay.active {
            display: flex;
        }

        .reconnecting-overlay .loading-spinner {
            width: 50px;
            height: 50px;
            border-width: 5px;
        }

        .reconnecting-overlay .reconnect-text {
            color: var(--gold);
            font-family: 'Oswald', sans-serif;
            font-size: 1.3rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .reconnecting-overlay .reconnect-subtext {
            color: #999;
            font-size: 0.9rem;
        }

        /* Rematch notice */
        .rematch-notice {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 12px 20px;
            margin: 15px 0;
            font-weight: 600;
            color: var(--gold);
            animation: pulseGlow 2s ease infinite;
        }

        /* Lobby Styles */
        .lobby {
            text-align: center;
            padding: 10px;
        }
        
        .lobby-header {
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 15px;
        }
        
        .lobby-header .red { color: var(--red-corner); }
        .lobby-header .blue { color: var(--blue-corner); }

        .lobby-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            color: var(--gold);
            margin-bottom: 15px;
        }

        .lobby-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 10px;
        }

        .lobby-btn {
            padding: 14px 20px;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lobby-btn.create {
            background: linear-gradient(135deg, var(--red-corner), var(--red-dark));
            color: white;
        }

        .lobby-btn.join {
            background: linear-gradient(135deg, var(--blue-corner), var(--blue-dark));
            color: white;
        }

        .lobby-btn.local {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 0.9rem;
            border: 1px solid var(--border-color);
        }
        
        .lobby-btn.leaderboard {
            background: transparent;
            color: var(--gold);
            font-size: 0.9rem;
            border: 1px solid var(--gold);
            margin-top: 10px;
        }

        .lobby-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .lobby-divider {
            display: flex;
            align-items: center;
            gap: 10px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 12px 0;
        }

        .lobby-divider::before,
        .lobby-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: var(--border-color);
        }

        /* Find Game Button */
        .lobby-btn.find {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        /* Find Game Lobby */
        .find-lobby {
            max-width: 500px;
        }

        .lobby-subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
            margin-bottom: 20px;
        }

        .public-games-list {
            max-height: 350px;
            overflow-y: auto;
            margin: 20px 0;
            padding-right: 5px;
        }

        .loading-games {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            padding: 40px;
            color: var(--text-secondary);
        }

        .no-games-message {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .no-games-icon {
            font-size: 3rem;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        .no-games-text {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .no-games-hint {
            font-size: 0.9rem;
        }

        /* Public Game Card */
        .game-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .game-card:hover {
            border-color: var(--gold);
            transform: translateX(5px);
        }

        .game-card-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .game-card-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--red-corner), var(--red-dark));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            color: white;
            border: 2px solid var(--gold);
        }

        .game-card-avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .game-card-details {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .game-card-host {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .game-card-meta {
            display: flex;
            gap: 12px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .game-card-rating {
            color: var(--gold);
            font-weight: 600;
        }

        .game-card-mode {
            background: var(--bg-primary);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            text-transform: uppercase;
        }

        .game-card-time {
            opacity: 0.7;
        }

        .game-card-join {
            background: linear-gradient(135deg, var(--success), #1e8449);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
        }

        .game-card-join:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(46, 204, 113, 0.4);
        }

        .find-game-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        /* Create Options */
        .create-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
        }

        .create-option-btn {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .create-option-btn:hover {
            border-color: var(--gold);
            transform: translateY(-2px);
        }

        .create-option-btn.public:hover {
            border-color: #9b59b6;
        }

        .create-option-btn.private:hover {
            border-color: var(--blue-corner);
        }

        .create-option-btn .option-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        .create-option-btn .option-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1.3rem;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .create-option-btn .option-desc {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .create-option-btn .rated-badge {
            position: absolute;
            top: 15px;
            right: 15px;
        }

        /* Game Code Display */
        .game-code-display {
            background: var(--bg-secondary);
            border: 3px solid var(--gold);
            border-radius: 12px;
            padding: 25px;
            margin: 20px 0;
        }

        .game-code-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .game-code {
            font-family: 'Oswald', sans-serif;
            font-size: 3rem;
            font-weight: 700;
            letter-spacing: 0.2em;
            color: var(--gold);
        }

        .game-code-hint {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 15px;
        }

        /* Share Buttons */
        .share-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .share-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .share-btn.copy {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--gold);
        }

        .share-btn.copy:hover {
            background: var(--gold);
            color: #000;
        }

        .share-btn.share {
            background: linear-gradient(135deg, #25D366, #128C7E);
            color: white;
        }

        .share-btn.share:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(37, 211, 102, 0.4);
        }

        .share-btn.sms {
            background: linear-gradient(135deg, #5FC9F8, #1DA1F2);
            color: white;
        }

        .share-btn.sms:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(29, 161, 242, 0.4);
        }

        .share-btn svg {
            width: 18px;
            height: 18px;
        }

        .copy-feedback {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: var(--success);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            z-index: 2000;
            transition: transform 0.2s;
        }

        .copy-feedback.show {
            transform: translate(-50%, -50%) scale(1);
        }

        /* Join Game Input */
        .join-section {
            margin: 20px 0;
        }

        .code-input {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .code-letter {
            width: 50px;
            height: 60px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--gold);
            outline: none;
            transition: all 0.2s;
        }

        .code-letter:focus {
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        /* Waiting Screen */
        .waiting {
            text-align: center;
            padding: 40px 20px;
        }

        .waiting-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--border-color);
            border-top-color: var(--gold);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .waiting-text {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .waiting-text::before {
            content: '';
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 3px solid rgba(255, 215, 0, 0.3);
            border-radius: 50%;
            border-top-color: var(--gold);
            animation: spin 0.8s linear infinite;
        }

        .waiting-subtext {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Player Badge */
        .player-badge {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin: 15px 0;
        }

        .player-badge.red {
            background: linear-gradient(135deg, var(--red-corner), var(--red-dark));
            color: white;
        }

        .player-badge.blue {
            background: linear-gradient(135deg, var(--blue-corner), var(--blue-dark));
            color: white;
        }

        /* Status Messages */
        .status-bar {
            background: var(--bg-secondary);
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .status-bar.waiting {
            border-left: 4px solid var(--gold);
        }

        .status-bar.your-turn {
            border-left: 4px solid var(--success);
            background: rgba(46, 204, 113, 0.1);
        }

        .status-bar.opponent-turn {
            border-left: 4px solid #666;
        }

        /* Connection Status */
        .connection-status {
            position: fixed;
            top: calc(env(safe-area-inset-top, 0px) + 14px);
            right: calc(env(safe-area-inset-right, 0px) + 60px);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 6px;
            z-index: 999;
        }

        .connection-status.connected {
            background: rgba(46, 204, 113, 0.2);
            color: var(--success);
        }

        .connection-status.disconnected {
            background: rgba(231, 76, 60, 0.2);
            color: var(--error);
        }

        .connection-status.connecting,
        .connection-status.reconnecting {
            background: rgba(255, 215, 0, 0.2);
            color: var(--gold);
        }

        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        .connection-dot.pulsing {
            animation: pulse 1s ease infinite;
        }

        /* Buttons */
        .btn {
            padding: 12px 30px;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--gold), #b8960c);
            color: #1a1a2e;
        }

        .btn-secondary {
            background: #333;
            color: #aaa;
        }

        .btn-red {
            background: linear-gradient(135deg, var(--red-corner), var(--red-dark));
            color: white;
        }

        .btn-blue {
            background: linear-gradient(135deg, var(--blue-corner), var(--blue-dark));
            color: white;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        /* Scoreboard */
        .scoreboard {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 20px;
        }

        .player-score {
            text-align: center;
        }

        .player-score.red .player-name { color: var(--red-corner); }
        .player-score.blue .player-name { color: var(--blue-corner); }

        .player-name {
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            text-transform: uppercase;
        }

        .round-wins {
            font-family: 'Oswald', sans-serif;
            font-size: 2rem;
            font-weight: 700;
        }

        .round-indicator {
            text-align: center;
        }

        .round-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .round-number {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gold);
        }

        /* Word Input */
        .phase-title {
            font-family: 'Oswald', sans-serif;
            font-size: 1.3rem;
            text-transform: uppercase;
            text-align: center;
            margin-bottom: 20px;
        }

        .phase-title.red { color: var(--red-corner); }
        .phase-title.blue { color: var(--blue-corner); }

        .word-input-section {
            text-align: center;
        }

        .instruction {
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .word-input {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }

        .letter-input {
            width: 50px;
            height: 60px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            outline: none;
            transition: all 0.2s;
        }

        .letter-input:focus {
            border-color: var(--gold);
        }

        .letter-input.filled {
            border-color: var(--success);
            background: rgba(46, 204, 113, 0.1);
        }

        .letter-input.invalid {
            border-color: var(--error);
            background: rgba(231, 76, 60, 0.15);
            color: var(--error);
        }

        .word-score {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 20px;
        }

        .word-score span {
            color: var(--gold);
            font-weight: 600;
        }

        /* Battle Area */
        .battle-area {
            text-align: center;
        }

        .turn-indicator {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            padding: 10px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .turn-indicator.red {
            background: linear-gradient(135deg, var(--red-corner), var(--red-dark));
        }

        .turn-indicator.blue {
            background: linear-gradient(135deg, var(--blue-corner), var(--blue-dark));
        }

        .turn-indicator.waiting {
            background: var(--border-color);
            color: var(--text-secondary);
        }

        .opponent-word {
            margin-bottom: 25px;
        }

        .word-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .word-points {
            color: var(--gold);
        }

        .word-display {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .letter-box {
            width: 50px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .letter-box.matched {
            background: rgba(255, 215, 0, 0.2);
            border-color: var(--gold);
            color: var(--gold);
            animation: letterMatch 0.5s ease;
        }

        .letter-box.revealed {
            background: rgba(46, 204, 113, 0.2);
            border-color: var(--success);
            color: var(--success);
            animation: letterReveal 0.6s ease;
        }

        /* Letter reveal animation */
        @keyframes letterReveal {
            0% {
                transform: rotateX(0deg);
                background: var(--bg-secondary);
            }
            50% {
                transform: rotateX(90deg);
                background: var(--bg-secondary);
            }
            51% {
                transform: rotateX(90deg);
                background: rgba(46, 204, 113, 0.2);
            }
            100% {
                transform: rotateX(0deg);
                background: rgba(46, 204, 113, 0.2);
            }
        }

        /* Letter match animation (gold) */
        @keyframes letterMatch {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.15);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Pulse animation for interactive elements */
        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
        }

        /* Shake animation for errors */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-8px); }
            80% { transform: translateX(8px); }
        }

        .shake {
            animation: shake 0.4s ease;
        }

        .revealed-count {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        /* Action Section */
        .action-section {
            margin-top: 20px;
        }

        .action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* Keyboard */
        .keyboard {
            display: none;
            margin-top: 20px;
        }

        .keyboard.active {
            display: block;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 6px;
            margin-bottom: 6px;
        }

        .key {
            width: 36px;
            height: 48px;
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            background: var(--key-bg);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        .key:hover:not(:disabled) {
            background: var(--key-hover);
            transform: translateY(-2px);
        }

        .key:active:not(:disabled) {
            transform: scale(0.95);
            background: var(--key-hover);
        }

        .key:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .key.used {
            background: var(--key-used);
            color: var(--text-secondary);
        }

        /* Solve Input */
        .solve-section {
            display: none;
            margin-top: 20px;
        }

        .solve-section.active {
            display: block;
        }

        .solve-input {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 15px;
        }

        .solve-letter {
            width: 50px;
            height: 60px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            text-align: center;
            text-transform: uppercase;
            background: var(--bg-secondary);
            border: 2px solid var(--gold);
            border-radius: 8px;
            color: var(--gold);
            outline: none;
        }

        /* Message Toast */
        .message-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            padding: 15px 30px;
            border-radius: 10px;
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            font-weight: 500;
            z-index: 1000;
            transition: transform 0.3s ease;
        }

        .message-toast.show {
            transform: translateX(-50%) translateY(0);
        }

        .message-toast.success {
            background: var(--success);
            color: white;
        }

        .message-toast.error {
            background: var(--error);
            color: white;
        }

        .message-toast.info {
            background: var(--blue-corner);
            color: white;
        }

        /* Round Result */
        .round-result {
            text-align: center;
            padding: 30px;
        }

        .result-title {
            font-family: 'Oswald', sans-serif;
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .revealed-word {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }

        /* Match Result */
        .match-result {
            text-align: center;
            padding: 40px 20px;
        }

        .champion-title {
            font-family: 'Oswald', sans-serif;
            font-size: 2.5rem;
            margin-bottom: 10px;
            animation: bounceIn 0.6s ease;
        }

        .champion-title.red { color: var(--red-corner); }
        .champion-title.blue { color: var(--blue-corner); }

        .trophy {
            font-size: 4rem;
            margin: 20px 0;
            animation: celebrate 0.8s ease infinite;
        }

        /* Version */
        .version {
            margin-top: 30px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Advanced Planning Mode */
        .word-planning-section {
            text-align: center;
        }

        .plan-round {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
        }

        .plan-label {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            color: var(--text-secondary);
            width: 70px;
            text-align: right;
        }

        .plan-input .letter-input {
            width: 42px;
            height: 50px;
            font-size: 1.5rem;
        }

        .letters-used {
            margin: 20px 0;
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .letters-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .letters-label span {
            color: var(--gold);
            font-weight: 600;
        }

        .available-letters {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 5px;
        }

        .letter-chip {
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Oswald', sans-serif;
            font-size: 0.8rem;
            border-radius: 4px;
            background: var(--border-color);
            color: var(--text-secondary);
        }

        .letter-chip.used {
            background: rgba(196, 30, 58, 0.3);
            color: var(--red-corner);
            text-decoration: line-through;
        }

        .letter-chip.available {
            background: rgba(46, 204, 113, 0.2);
            color: var(--success);
        }

        .plan-status {
            min-height: 24px;
            margin: 10px 0;
            font-size: 0.9rem;
        }

        .plan-status.error {
            color: var(--error);
        }

        .plan-status.success {
            color: var(--success);
        }

        /* Mobile adjustments */
        @media (max-width: 400px) {
            .letter-input, .letter-box, .solve-letter, .code-letter {
                width: 42px;
                height: 52px;
                font-size: 1.5rem;
            }

            .key {
                width: 32px;
                height: 48px;
                font-size: 1rem;
                min-width: 32px;
                touch-action: manipulation;
            }

            .keyboard-row {
                gap: 4px;
            }

            .game-code {
                font-size: 2.5rem;
            }

            .plan-input .letter-input {
                width: 38px;
                height: 46px;
                font-size: 1.3rem;
            }

            .plan-label {
                width: 55px;
                font-size: 0.9rem;
            }
        }

        /* Medium mobile screens */
        @media (max-width: 500px) and (min-width: 401px) {
            .key {
                width: 34px;
                height: 50px;
                font-size: 1.1rem;
            }

            .keyboard-row {
                gap: 5px;
            }
        }

        /* Very small screens (320px phones) */
        @media (max-width: 340px) {
            .key {
                width: 26px;
                height: 44px;
                font-size: 0.9rem;
            }

            .keyboard-row {
                gap: 3px;
            }

            .letter-box {
                width: 40px;
                height: 48px;
                font-size: 1.4rem;
            }
        }

        /* User Profile & Auth Styles */
        .user-bar {
            position: fixed;
            top: calc(env(safe-area-inset-top, 0px) + 10px);
            left: calc(env(safe-area-inset-left, 0px) + 10px);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
        }

        .back-to-gs {
            position: fixed;
            top: calc(env(safe-area-inset-top, 0px) + 10px);
            right: calc(env(safe-area-inset-right, 0px) + 10px);
            padding: 6px 12px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            background: rgba(255,215,0,0.15);
            color: var(--gold);
            border: 1px solid var(--gold);
            border-radius: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            text-decoration: none;
            z-index: 100;
        }

        .back-to-gs:hover {
            background: rgba(255,215,0,0.25);
            transform: scale(1.05);
        }

        .back-to-gs .back-text {
            font-size: 0.7rem;
        }

        @media (max-width: 400px) {
            .back-to-gs .back-text {
                display: none;
            }
        }

        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid var(--gold);
            cursor: pointer;
        }

        .user-info {
            display: flex;
            flex-direction: column;
            cursor: pointer;
        }

        .user-name {
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
            color: var(--light);
        }

        .user-rating {
            font-size: 0.75rem;
            color: var(--gold);
        }

        .sign-in-btn {
            padding: 6px 12px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            background: #4285f4;
            color: white;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }
        
        .sign-in-btn svg {
            width: 14px;
            height: 14px;
        }

        .sign-in-btn:hover {
            background: #3367d6;
            transform: scale(1.05);
        }

        .sign-in-btn img {
            width: 18px;
            height: 18px;
        }

        /* Rank Badges */
        .rank-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 12px;
            font-family: 'Oswald', sans-serif;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .rank-badge.rookie { background: #cd7f32; color: #fff; }
        .rank-badge.contender { background: #c0c0c0; color: #333; }
        .rank-badge.fighter { background: #ffd700; color: #333; }
        .rank-badge.champion { background: linear-gradient(135deg, #ffd700, #ff8c00); color: #333; }
        .rank-badge.legend { background: linear-gradient(135deg, #9b59b6, #8e44ad); color: #fff; }

        /* Profile Modal */
        .profile-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .profile-modal.active {
            display: flex;
        }

        .profile-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .profile-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .profile-avatar {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid var(--gold);
        }

        .profile-details h2 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            color: var(--light);
            margin-bottom: 5px;
        }

        .profile-rating-large {
            font-family: 'Oswald', sans-serif;
            font-size: 2rem;
            color: var(--gold);
        }

        .profile-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            color: var(--light);
        }

        .stat-label {
            font-size: 0.75rem;
            color: #888;
            text-transform: uppercase;
        }

        .match-history {
            margin-top: 20px;
        }

        .match-history h3 {
            font-family: 'Oswald', sans-serif;
            font-size: 1rem;
            color: #888;
            margin-bottom: 10px;
        }

        .match-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .match-opponent {
            font-size: 0.9rem;
        }

        .match-result {
            font-family: 'Oswald', sans-serif;
            font-size: 0.9rem;
        }

        .match-result.win { color: var(--success); }
        .match-result.loss { color: var(--error); }

        .match-rating-change {
            font-size: 0.85rem;
            font-weight: 600;
        }

        .match-rating-change.positive { color: var(--success); }
        .match-rating-change.negative { color: var(--error); }

        /* Profile Tabs */
        .profile-tabs {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            margin-bottom: 15px;
        }

        .profile-tab {
            flex: 1;
            padding: 10px 15px;
            background: rgba(255,255,255,0.05);
            border: none;
            border-radius: 8px;
            color: #888;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .profile-tab:hover {
            background: rgba(255,255,255,0.1);
        }

        .profile-tab.active {
            background: var(--gold);
            color: var(--dark);
            font-weight: 600;
        }

        /* Friends Section */
        .friends-section {
            margin-top: 10px;
        }

        .friend-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 8px;
            margin-bottom: 8px;
        }

        .friend-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .friend-name {
            font-size: 0.95rem;
            font-weight: 500;
        }

        .friend-rating {
            font-size: 0.85rem;
            color: var(--gold);
        }

        .friend-remove {
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 5px;
            transition: color 0.2s;
        }

        .friend-remove:hover {
            color: var(--error);
        }

        /* Leaderboard Filter */
        .leaderboard-filter {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .filter-btn {
            flex: 1;
            padding: 8px 12px;
            background: rgba(255,255,255,0.05);
            border: none;
            border-radius: 8px;
            color: #888;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .filter-btn.active {
            background: var(--gold);
            color: var(--dark);
            font-weight: 600;
        }

        /* Add Friend Button States */
        #add-friend-btn.friend-added {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
            border: 1px solid #4ade80;
        }

        /* Leaderboard friend highlight */
        .leaderboard-item.friend {
            background: rgba(255, 215, 0, 0.1);
        }

        /* Leaderboard Modal */
        .leaderboard-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .leaderboard-modal.active {
            display: flex;
        }

        .leaderboard-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .leaderboard-content h2 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.5rem;
            color: var(--gold);
            text-align: center;
            margin-bottom: 20px;
        }

        .leaderboard-list {
            list-style: none;
        }

        .leaderboard-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(255,255,255,0.03);
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .leaderboard-item.me {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid var(--gold);
        }

        .leaderboard-rank {
            font-family: 'Oswald', sans-serif;
            font-size: 1.2rem;
            color: #888;
            width: 30px;
            text-align: center;
        }

        .leaderboard-rank.top-3 { color: var(--gold); }

        .leaderboard-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
        }

        .leaderboard-name {
            flex: 1;
            font-size: 0.95rem;
        }

        .leaderboard-rating {
            font-family: 'Oswald', sans-serif;
            font-size: 1.1rem;
            color: var(--gold);
            min-width: 50px;
            text-align: right;
        }

        .leaderboard-record {
            font-size: 0.8rem;
            color: var(--text-secondary);
            min-width: 45px;
            text-align: center;
        }

        .leaderboard-divider-line {
            height: 1px;
            background: var(--border-color);
            margin: 12px 0;
            list-style: none;
        }

        /* Rated match indicator */
        .rated-badge {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid var(--gold);
            border-radius: 12px;
            font-size: 0.7rem;
            color: var(--gold);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .unrated-badge {
            display: inline-block;
            padding: 3px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            border-radius: 12px;
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Forfeit Button */
        .forfeit-btn {
            display: block;
            margin: 30px auto 0;
            padding: 8px 16px;
            background: transparent;
            border: 1px solid #555;
            border-radius: 8px;
            color: #777;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .forfeit-btn:hover {
            border-color: #d32f2f;
            color: #d32f2f;
            background: rgba(211, 47, 47, 0.1);
        }

        /* Forfeit Confirmation Modal */
        .forfeit-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.85);
            z-index: 1001;
            align-items: center;
            justify-content: center;
        }

        .forfeit-modal.active {
            display: flex;
        }

        .forfeit-content {
            background: var(--dark);
            border-radius: 16px;
            padding: 30px;
            max-width: 380px;
            width: 90%;
            text-align: center;
            border: 2px solid #d32f2f;
        }

        .forfeit-content h3 {
            font-family: 'Oswald', sans-serif;
            font-size: 1.4rem;
            color: #d32f2f;
            margin-bottom: 15px;
        }

        .forfeit-content p {
            color: #ccc;
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .forfeit-warning {
            background: rgba(211, 47, 47, 0.15);
            border: 1px solid #d32f2f;
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            color: #ff6b6b;
            font-size: 0.9rem;
        }

        .forfeit-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .forfeit-buttons .btn {
            flex: 1;
        }

        .btn-danger {
            background: linear-gradient(135deg, #d32f2f, #b71c1c);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-danger:hover {
            background: linear-gradient(135deg, #e53935, #c62828);
            transform: translateY(-1px);
        }
        
        /* Plain Mode Styles */
        body.plain-mode .profile-link-section,
        body.plain-mode #leaderboard-preview {
            display: none;
        }
        
        /* Sync Indicator */
        .sync-indicator {
            position: fixed;
            top: 20px;
            right: 70px;
            padding: 6px 10px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            display: none;
            z-index: 1000;
        }
        
        .sync-indicator:hover {
            background: var(--card-hover);
        }
        
        .sync-indicator.syncing {
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <!-- Tutorial Prompt Modal (v1.0.0) -->
    <div class="tutorial-prompt-overlay" id="tutorial-prompt-overlay">
        <div class="tutorial-prompt-modal">
            <h2>Welcome to Word Boxing! ðŸ¥Š</h2>
            <p>A competitive 1v1 word puzzle game where you try to guess your opponent's secret word before they guess yours.</p>
            <div class="tutorial-prompt-buttons">
                <button class="tutorial-prompt-skip" onclick="TutorialManager.dismissPrompt()">Skip Tutorial</button>
                <button class="tutorial-prompt-start" onclick="TutorialManager.acceptPrompt()">Next â†’</button>
            </div>
        </div>
    </div>

    <!-- Tutorial Overlay -->
    <div class="tutorial-overlay" id="tutorial-overlay">
        <div class="tutorial-highlight" id="tutorial-highlight"></div>
        <div class="tutorial-tooltip" id="tutorial-tooltip">
            <div class="tutorial-step-indicator" id="tutorial-step-indicator" style="color: #ccc;">Step 1 of 8</div>
            <div class="tutorial-title" id="tutorial-title" style="color: #ffd700;">Welcome to Word Boxing!</div>
            <div class="tutorial-description" id="tutorial-description" style="color: #ffffff;">
                Learn how to play this competitive word puzzle game.
            </div>
            <div class="tutorial-nav">
                <button class="tutorial-skip" onclick="TutorialManager.skip()">Skip Tutorial</button>
                <button class="tutorial-next" onclick="TutorialManager.next()">Next â†’</button>
            </div>
            <div class="tutorial-progress" id="tutorial-progress"></div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Loading...</div>
    </div>

    <!-- Opponent Disconnect Banner -->
    <div class="disconnect-banner" id="disconnect-banner">
        <span>âš ï¸ Opponent Disconnected</span>
        <span class="countdown" id="disconnect-countdown">60</span>
    </div>

    <!-- Reconnecting Overlay -->
    <div class="reconnecting-overlay" id="reconnecting-overlay">
        <div class="loading-spinner"></div>
        <div class="reconnect-text">Reconnecting...</div>
        <div class="reconnect-subtext" id="reconnect-subtext">Please wait while we restore your game</div>
    </div>

    <!-- User Bar (Top Left) -->
    <div class="user-bar" id="user-bar">
        <button class="sign-in-btn" id="sign-in-btn" onclick="signInWithGoogle()">
            <svg width="18" height="18" viewBox="0 0 24 24"><path fill="#fff" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#fff" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#fff" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#fff" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
            Sign In
        </button>
        <div id="user-profile" style="display: none;" onclick="showProfile()">
            <img class="user-avatar" id="user-avatar" src="" alt="Avatar">
            <div class="user-info">
                <span class="user-name" id="user-name">Player</span>
                <span class="user-rating" id="user-rating">1200</span>
            </div>
        </div>
    </div>

    <!-- Back to Game Shelf (Top Right) -->
    <a href="https://gameshelf.co/" class="back-to-gs" aria-label="Back to Game Shelf">â† <span class="back-text">Game Shelf</span></a>

    <!-- Menu Button -->
    <button class="menu-btn" onclick="toggleSettingsMenu()" title="Menu">
        <svg viewBox="0 0 24 24" fill="none">
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
        </svg>
    </button>
    
    <!-- Connection Status -->
    <div class="connection-status connected" id="connection-status">
        <div class="connection-dot"></div>
        <span>Online</span>
    </div>

    <div class="container">
        <!-- Phase: Lobby -->
        <div class="phase active" id="phase-lobby">
            <div class="lobby">
                <div class="lobby-header">
                    <span class="red">Word</span><span class="blue">Boxing</span>
                </div>
                
                <div class="lobby-divider">online</div>
                <div class="lobby-options">
                    <button class="lobby-btn create" onclick="showCreateOptions()">
                        Create Game
                    </button>
                    <button class="lobby-btn find" onclick="showFindGame()">
                        Find Game <span class="rated-badge">Public</span>
                    </button>
                    <button class="lobby-btn join" onclick="showJoinGame()">
                        Join by Code
                    </button>
                </div>
                
                <div class="lobby-divider">local</div>
                <div class="lobby-options">
                    <button class="lobby-btn local" onclick="startPassAndPlay()">
                        Pass & Play <span class="unrated-badge">Unrated</span>
                    </button>
                </div>
                
                <button class="lobby-btn leaderboard" onclick="showLeaderboard()">
                    ðŸ† Leaderboard
                </button>
            </div>
        </div>

        <!-- Phase: Find Game (Public Lobby) -->
        <div class="phase" id="phase-find-game">
            <div class="lobby find-lobby">
                <div class="lobby-title">ðŸ” Find a Game</div>
                <div class="lobby-subtitle">Join an open game or wait for a match</div>
                
                <div class="public-games-list" id="public-games-list">
                    <div class="loading-games">
                        <div class="waiting-spinner"></div>
                        <div>Loading games...</div>
                    </div>
                </div>
                
                <div class="no-games-message" id="no-games-message" style="display: none;">
                    <div class="no-games-icon">ðŸ¥Š</div>
                    <div class="no-games-text">No open games right now</div>
                    <div class="no-games-hint">Create your own and others will join!</div>
                </div>
                
                <div class="find-game-actions">
                    <button class="btn btn-primary" onclick="createPublicGame()">Create Public Game</button>
                    <button class="btn btn-secondary" onclick="showPhase('phase-lobby')">Back</button>
                </div>
            </div>
        </div>

        <!-- Phase: Create Game Options -->
        <div class="phase" id="phase-create-options">
            <div class="lobby">
                <div class="lobby-title">ðŸ¥Š Create Game</div>
                <div class="lobby-subtitle">Choose how others can join</div>
                
                <div class="create-options">
                    <button class="create-option-btn public" onclick="createPublicGame()">
                        <div class="option-icon">ðŸŒ</div>
                        <div class="option-title">Public Game</div>
                        <div class="option-desc">Anyone can find and join from the lobby</div>
                        <span class="rated-badge">Rated</span>
                    </button>
                    
                    <button class="create-option-btn private" onclick="createGame()">
                        <div class="option-icon">ðŸ”’</div>
                        <div class="option-title">Private Game</div>
                        <div class="option-desc">Share the code with a specific friend</div>
                        <span class="rated-badge">Rated</span>
                    </button>
                </div>
                
                <button class="btn btn-secondary" onclick="showPhase('phase-lobby')" style="margin-top: 20px;">Back</button>
            </div>
        </div>

        <!-- Phase: Pass & Play - Pass to Red -->
        <div class="phase" id="phase-pass-red">
            <div class="waiting">
                <div class="player-badge red">ðŸ¥Š Red Corner</div>
                <div style="font-size: 1.3rem; margin: 20px 0;">Pass the device to <strong style="color: var(--red-corner);">Red</strong></div>
                <button class="btn btn-red" onclick="continueAsPlayer('red')" style="margin-top: 20px; font-size: 1.2rem; padding: 15px 40px;">I'm Red - Continue</button>
            </div>
        </div>

        <!-- Phase: Pass & Play - Pass to Blue -->
        <div class="phase" id="phase-pass-blue">
            <div class="waiting">
                <div class="player-badge blue">Blue Corner ðŸ¥Š</div>
                <div style="font-size: 1.3rem; margin: 20px 0;">Pass the device to <strong style="color: var(--blue-corner);">Blue</strong></div>
                <button class="btn btn-blue" onclick="continueAsPlayer('blue')" style="margin-top: 20px; font-size: 1.2rem; padding: 15px 40px;">I'm Blue - Continue</button>
            </div>
        </div>

        <!-- Phase: Create Game - Waiting for Opponent -->
        <div class="phase" id="phase-create-waiting">
            <div class="waiting">
                <div class="player-badge red">You are Red Corner</div>
                <div class="game-code-display" id="private-game-info">
                    <div class="game-code-label">Share this code with your opponent:</div>
                    <div class="game-code" id="display-game-code">-----</div>
                    <div class="share-buttons">
                        <button class="share-btn copy" onclick="copyGameCode()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            Copy Code
                        </button>
                        <button class="share-btn share" onclick="shareGameCode()" id="share-btn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <circle cx="18" cy="5" r="3"></circle>
                                <circle cx="6" cy="12" r="3"></circle>
                                <circle cx="18" cy="19" r="3"></circle>
                                <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
                                <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
                            </svg>
                            Share
                        </button>
                    </div>
                    <div class="game-code-hint">ðŸ“± Send the code to start playing!</div>
                </div>
                <div class="game-code-display" id="public-game-info" style="display: none;">
                    <div class="game-code-label">ðŸŒ Listed in Public Lobby</div>
                    <div class="game-code-hint" style="margin-top: 10px;">Players can find and join your game from the lobby.</div>
                </div>
                <div class="waiting-spinner"></div>
                <div class="waiting-text">Waiting for opponent to join...</div>
                <button class="btn btn-secondary" onclick="cancelGame()" style="margin-top: 20px;">Cancel</button>
            </div>
        </div>

        <!-- Copy Feedback -->
        <div class="copy-feedback" id="copy-feedback">âœ“ Code Copied!</div>

        <!-- Phase: Join Game -->
        <div class="phase" id="phase-join">
            <div class="lobby">
                <div class="lobby-title">ðŸŽ¯ Join Game</div>
                <p class="instruction">Enter the 5-letter game code:</p>
                <div class="join-section">
                    <div class="code-input" id="code-input">
                        <input type="text" class="code-letter" maxlength="1" data-index="0">
                        <input type="text" class="code-letter" maxlength="1" data-index="1">
                        <input type="text" class="code-letter" maxlength="1" data-index="2">
                        <input type="text" class="code-letter" maxlength="1" data-index="3">
                        <input type="text" class="code-letter" maxlength="1" data-index="4">
                    </div>
                    <button class="btn btn-blue" id="join-btn" onclick="joinGame()" disabled>Join Game</button>
                </div>
                <button class="btn btn-secondary" onclick="showPhase('phase-lobby')" style="margin-top: 15px;">Back</button>
            </div>
        </div>

        <!-- Phase: Joined - Waiting to Start -->
        <div class="phase" id="phase-join-waiting">
            <div class="waiting">
                <div class="player-badge blue">You are Blue Corner</div>
                <div class="waiting-spinner"></div>
                <div class="waiting-text">Joined game!</div>
                <div class="waiting-subtext">Waiting for game to start...</div>
                <button class="btn btn-secondary" onclick="cancelGame()" style="margin-top: 20px;">Leave Game</button>
            </div>
        </div>

        <!-- Phase: Mode Selection (Host only) -->
        <div class="phase" id="phase-mode-select">
            <div class="lobby">
                <div class="lobby-title">Choose Game Mode</div>
                <div class="lobby-options">
                    <button class="lobby-btn create" onclick="selectMode('beginner')">
                        ðŸ¥Š Beginner<br>
                        <span style="font-size: 0.8rem; opacity: 0.8;">Pick new word each round</span>
                    </button>
                    <button class="lobby-btn join" onclick="selectMode('advanced')">
                        ðŸ† Advanced<br>
                        <span style="font-size: 0.8rem; opacity: 0.8;">Plan all 3 words upfront</span>
                    </button>
                </div>
                <button class="btn btn-secondary" onclick="cancelModeSelect()" style="margin-top: 20px;">Back</button>
            </div>
        </div>

        <!-- Scoreboard (shown during game) -->
        <div class="scoreboard" id="scoreboard" style="display: none;">
            <div class="player-score red">
                <div class="player-name">ðŸ¥Š Red</div>
                <div class="round-wins" id="red-wins">0</div>
            </div>
            <div class="round-indicator">
                <div class="round-label">Round</div>
                <div class="round-number" id="round-number">1</div>
            </div>
            <div class="player-score blue">
                <div class="player-name">Blue ðŸ¥Š</div>
                <div class="round-wins" id="blue-wins">0</div>
            </div>
        </div>

        <!-- Mode Badge (shown during game) -->
        <div class="mode-badge-container" id="mode-badge-container" style="display: none; text-align: center; margin-bottom: 10px;">
            <span id="mode-badge" style="display: inline-block; padding: 4px 12px; border-radius: 20px; font-family: 'Oswald', sans-serif; font-size: 0.8rem; letter-spacing: 0.1em; background: linear-gradient(135deg, #4a3a00, #2a2200); border: 1px solid var(--gold); color: var(--gold);">ADVANCED</span>
        </div>

        <!-- Phase: Advanced Word Planning -->
        <div class="phase" id="phase-word-planning">
            <div class="phase-title" id="planning-title">Plan Your 3 Words</div>
            <div class="word-planning-section">
                <p class="instruction">Enter all 3 words. No letter can repeat across words!</p>
                
                <div class="plan-round">
                    <div class="plan-label">Round 1:</div>
                    <div class="word-input plan-input" id="plan-word-1"></div>
                </div>
                <div class="plan-round">
                    <div class="plan-label">Round 2:</div>
                    <div class="word-input plan-input" id="plan-word-2"></div>
                </div>
                <div class="plan-round">
                    <div class="plan-label">Round 3:</div>
                    <div class="word-input plan-input" id="plan-word-3"></div>
                </div>
                
                <div class="letters-used">
                    <div class="letters-label">Letters used: <span id="letters-used-count">0</span>/26</div>
                    <div class="available-letters" id="available-letters"></div>
                </div>
                
                <div class="plan-status" id="plan-status"></div>
                <button class="btn btn-primary" id="submit-plan-btn" onclick="submitPlan()" disabled>Lock In All Words</button>
                <button class="forfeit-btn" onclick="confirmForfeit()" style="margin-top: 30px;">ðŸ³ï¸ Forfeit Match</button>
            </div>
        </div>

        <!-- Phase: Waiting for Opponent's Plan -->
        <div class="phase" id="phase-waiting-plan">
            <div class="waiting">
                <div class="waiting-spinner"></div>
                <div class="waiting-text">Waiting for opponent to plan their words...</div>
                <div class="waiting-subtext">You're all set! 3 words locked in.</div>
                <button class="forfeit-btn" onclick="confirmForfeit()" style="margin-top: 30px;">ðŸ³ï¸ Forfeit Match</button>
            </div>
        </div>

        <!-- Phase: Word Input (Beginner Mode) -->
        <div class="phase" id="phase-word-input">
            <div class="phase-title" id="input-title">Enter Your Word</div>
            <div class="word-input-section">
                <p class="instruction">Enter a 5-letter word for your opponent to guess</p>
                <div class="word-input" id="word-input"></div>
                <div class="word-score">Word Score: <span id="word-score">0</span> pts</div>
                <button class="btn btn-primary" id="submit-word-btn" onclick="submitWord()" disabled>Submit Word</button>
                <button class="forfeit-btn" onclick="confirmForfeit()" style="margin-top: 30px;">ðŸ³ï¸ Forfeit Match</button>
            </div>
        </div>

        <!-- Phase: Waiting for Opponent's Word -->
        <div class="phase" id="phase-waiting-word">
            <div class="waiting">
                <div class="waiting-spinner"></div>
                <div class="waiting-text">Waiting for opponent's word...</div>
                <button class="forfeit-btn" onclick="confirmForfeit()" style="margin-top: 30px;">ðŸ³ï¸ Forfeit Match</button>
            </div>
        </div>

        <!-- Phase: Battle -->
        <div class="phase" id="phase-battle">
            <div class="battle-area">
                <div class="status-bar" id="battle-status">
                    <span id="battle-status-text">Battle!</span>
                </div>
                
                <div class="opponent-word">
                    <div class="word-label">Opponent's Word</div>
                    <div class="word-display" id="opponent-word-display"></div>
                    <div class="revealed-count">Opponent sees <span id="revealed-count">0</span> of 5 letters in YOUR word</div>
                </div>

                <div class="action-section" id="action-section">
                    <div class="action-buttons" id="action-buttons">
                        <button class="btn btn-secondary" onclick="showGuessMode()">Guess Letter</button>
                        <button class="btn btn-primary" onclick="showSolveMode()">Solve Word</button>
                    </div>

                    <div class="keyboard" id="keyboard"></div>

                    <div class="solve-section" id="solve-section">
                        <div class="solve-input" id="solve-input"></div>
                        <button class="btn btn-primary" onclick="attemptSolve()">Submit Answer</button>
                        <button class="btn btn-secondary" onclick="cancelSolve()" style="margin-left: 10px;">Cancel</button>
                    </div>
                </div>
                
                <button class="forfeit-btn" onclick="confirmForfeit()">ðŸ³ï¸ Forfeit Match</button>
            </div>
        </div>

        <!-- Phase: Waiting for Opponent's Turn -->
        <div class="phase" id="phase-waiting-turn">
            <div class="battle-area">
                <div class="status-bar opponent-turn">
                    <span>â³ Opponent is thinking...</span>
                </div>
                
                <div class="opponent-word">
                    <div class="word-label">Opponent's Word</div>
                    <div class="word-display" id="waiting-opponent-display"></div>
                    <div class="revealed-count">Opponent sees <span id="waiting-revealed-count">0</span> of 5 letters in YOUR word</div>
                </div>
                
                <button class="forfeit-btn" onclick="confirmForfeit()">ðŸ³ï¸ Forfeit Match</button>
            </div>
        </div>

        <!-- Phase: Round Result -->
        <div class="phase" id="phase-round-result">
            <div class="round-result">
                <div class="result-title" id="round-winner-title">Round Over!</div>
                <div class="revealed-word">
                    <div>Your word: <span id="reveal-your-word">-----</span></div>
                    <div>Their word: <span id="reveal-their-word">-----</span></div>
                </div>
                <div class="waiting-text" id="round-result-status">Waiting for next round...</div>
                <button class="forfeit-btn" id="round-result-forfeit" onclick="confirmForfeit()" style="margin-top: 30px; display: none;">ðŸ³ï¸ Forfeit Match</button>
            </div>
        </div>

        <!-- Phase: Match Result -->
        <div class="phase" id="phase-match-result">
            <div class="match-result">
                <div class="trophy">ðŸ†</div>
                <div class="champion-title" id="champion-title">Champion!</div>
                <div class="revealed-word">
                    Final Score: <span id="final-score">0 - 0</span>
                </div>
                <div class="revealed-word" id="final-words-container" style="margin-top: 10px; font-size: 0.9rem;">
                    <div>Your word: <span id="final-your-word">-----</span></div>
                    <div>Their word: <span id="final-their-word">-----</span></div>
                </div>
                <div id="rating-change-container" style="margin-top: 15px; font-size: 1.1rem; font-weight: bold; display: none;">
                    <span id="rating-change-text"></span>
                </div>
                <div id="add-friend-container" style="margin-top: 15px; display: none;">
                    <button class="btn btn-secondary" id="add-friend-btn" onclick="toggleFriend()" style="font-size: 0.9rem;">
                        ðŸ‘¤ Add Friend
                    </button>
                </div>
                <div id="rematch-notice" class="rematch-notice" style="display: none;">
                    âš”ï¸ Opponent wants a rematch!
                </div>
                <div id="match-result-buttons">
                    <button class="btn btn-share" onclick="shareResults()" style="margin-top: 20px; background: linear-gradient(135deg, #1da1f2, #0d8ecf); border-color: #1da1f2;">
                        ðŸ“¤ Share Results
                    </button>
                    <button class="btn btn-primary" id="rematch-btn" onclick="requestRematch()" style="margin-top: 10px;">Rematch</button>
                    <button class="btn btn-secondary" id="exit-btn" onclick="exitToLobby()" style="margin-top: 10px;">Exit to Lobby</button>
                </div>
                <div id="match-result-waiting" style="display: none;">
                    <div class="waiting-text" id="rematch-waiting-text">Waiting for opponent...</div>
                    <button class="btn btn-secondary" onclick="cancelRematchRequest()" style="margin-top: 15px; font-size: 0.85rem;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Message Toast -->
    <div class="message-toast" id="message-toast"></div>

    <!-- Profile Modal -->
    <div class="profile-modal" id="profile-modal" onclick="closeProfileModal(event)">
        <div class="profile-content" onclick="event.stopPropagation()">
            <div class="profile-header">
                <img class="profile-avatar" id="profile-avatar" src="" alt="Avatar">
                <div class="profile-details">
                    <h2 id="profile-name">Player Name</h2>
                    <div id="profile-rank-badge"></div>
                </div>
            </div>
            <div class="profile-rating-large" id="profile-rating">1200</div>
            <div style="font-size: 0.85rem; color: #888; margin-bottom: 20px;">
                Peak: <span id="profile-peak-rating">1200</span>
            </div>
            
            <div class="profile-stats">
                <div class="stat-box">
                    <div class="stat-value" id="profile-wins">0</div>
                    <div class="stat-label">Wins</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="profile-losses">0</div>
                    <div class="stat-label">Losses</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="profile-streak">0</div>
                    <div class="stat-label">Streak</div>
                </div>
            </div>
            
            <div class="profile-tabs">
                <button class="profile-tab active" id="tab-matches" onclick="showProfileTab('matches')">Recent Matches</button>
                <button class="profile-tab" id="tab-friends" onclick="showProfileTab('friends')">Friends (<span id="friends-count">0</span>)</button>
            </div>
            
            <div class="match-history" id="profile-matches-section">
                <div id="match-history-list">
                    <p style="color: #666; text-align: center; padding: 20px;">No matches yet</p>
                </div>
            </div>
            
            <div class="friends-section" id="profile-friends-section" style="display: none;">
                <div id="friends-list">
                    <p style="color: #666; text-align: center; padding: 20px;">No friends yet. Add friends after matches!</p>
                </div>
            </div>
            
            <button class="btn btn-secondary" onclick="signOut()" style="width: 100%; margin-top: 20px;">Sign Out</button>
            <button class="btn btn-secondary" onclick="closeProfile()" style="width: 100%; margin-top: 10px;">Close</button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div class="leaderboard-modal" id="leaderboard-modal" onclick="closeLeaderboardModal(event)">
        <div class="leaderboard-content" onclick="event.stopPropagation()">
            <h2>ðŸ† Leaderboard</h2>
            <div class="leaderboard-filter">
                <button class="filter-btn active" id="filter-all" onclick="setLeaderboardFilter('all')">All Players</button>
                <button class="filter-btn" id="filter-friends" onclick="setLeaderboardFilter('friends')">Friends Only</button>
            </div>
            <ul class="leaderboard-list" id="leaderboard-list">
                <li style="color: #666; text-align: center; padding: 20px;">Loading...</li>
            </ul>
            <button class="btn btn-secondary" onclick="closeLeaderboard()" style="width: 100%; margin-top: 20px;">Close</button>
        </div>
    </div>

    <!-- Forfeit Confirmation Modal -->
    <div class="forfeit-modal" id="forfeit-modal" onclick="closeForfeitModal(event)">
        <div class="forfeit-content" onclick="event.stopPropagation()">
            <h3>ðŸ³ï¸ Forfeit Match?</h3>
            <p>Are you sure you want to forfeit this match?</p>
            <p>This will count as a <strong>loss</strong> and your opponent will win.</p>
            <div class="forfeit-warning" id="forfeit-penalty-warning" style="display: none;">
                âš ï¸ Since the battle has started, you'll receive an extra <strong>-25 rating penalty</strong> for forfeiting.
            </div>
            <div class="forfeit-buttons">
                <button class="btn btn-secondary" onclick="closeForfeit()">Cancel</button>
                <button class="btn btn-danger" onclick="executeForfeit()">Forfeit</button>
            </div>
        </div>
    </div>

    <!-- Settings Menu Modal -->
    <div class="settings-modal" id="settings-modal" onclick="closeSettingsModal(event)">
        <div class="settings-content" onclick="event.stopPropagation()">
            <div class="settings-header">
                <h3>ðŸ“‹ Menu</h3>
                <button class="settings-close" onclick="closeSettings()">Ã—</button>
            </div>
            
            <!-- 1. GAME MODE (Difficulty equivalent for multiplayer) -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸŽ® Game Mode</div>
                <div class="settings-item">
                    <div>
                        <div class="settings-item-label">Default Mode</div>
                        <div class="settings-item-desc">Beginner: new word each round. Advanced: plan all 3 upfront!</div>
                    </div>
                    <select class="settings-select" id="default-mode-select" onchange="setDefaultMode(this.value)">
                        <option value="ask">Always Ask</option>
                        <option value="beginner">Beginner</option>
                        <option value="advanced">Advanced</option>
                    </select>
                </div>
            </div>

            <!-- 2. DISPLAY -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸŽ¨ Display</div>
                <div class="settings-item">
                    <div>
                        <div class="settings-item-label">Dark Mode</div>
                    </div>
                    <div class="toggle-switch" id="dark-mode-toggle" onclick="toggleThemeFromMenu()"></div>
                </div>
            </div>

            <!-- 3. SOUND -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸ”Š Sound</div>
                <div class="settings-item">
                    <div>
                        <div class="settings-item-label">Sound Effects</div>
                    </div>
                    <div class="toggle-switch active" id="sound-toggle" onclick="toggleSound()"></div>
                </div>
                <div class="settings-item">
                    <div>
                        <div class="settings-item-label">Volume</div>
                    </div>
                    <input type="range" id="sound-volume" min="0" max="100" value="50"
                           oninput="setSoundVolume(this.value)"
                           style="width: 100px; cursor: pointer;">
                </div>
                <div class="settings-item" style="cursor: pointer;" onclick="testSounds()">
                    <div>
                        <div class="settings-item-label">ðŸ”Š Test Sounds</div>
                    </div>
                </div>
            </div>

            <!-- 4. TUTORIAL -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸ“– Tutorial</div>
                <div class="settings-item">
                    <div>
                        <div class="settings-item-label">Show on First Visit</div>
                    </div>
                    <div class="toggle-switch active" id="show-overview-toggle" onclick="toggleShowOverview()"></div>
                </div>
                <div class="settings-item" style="cursor: pointer;" onclick="TutorialManager.restart(); toggleSettingsMenu();">
                    <div>
                        <div class="settings-item-label">ðŸŽ“ Replay Tutorial</div>
                    </div>
                    <span style="color: var(--gold);">â–¶</span>
                </div>
            </div>

            <!-- 5. HOW TO PLAY / ABOUT -->
            <div class="settings-section">
                <div class="settings-section-title">â“ Help</div>
                <button class="settings-btn" onclick="showGameOverview()">
                    <span>ðŸ“–</span> How to Play
                </button>
                <button class="settings-btn" onclick="showAbout()">
                    <span>â„¹ï¸</span> About Word Boxing
                </button>
            </div>

            <!-- 5.5. PLAIN MODE -->
            <div class="settings-section">
                <div class="settings-section-title">ðŸ“‹ Plain Mode</div>
                <div class="settings-item">
                    <div>
                        <div class="settings-item-label">Plain Mode</div>
                        <div class="settings-item-desc">Simplified visual experience</div>
                    </div>
                    <div class="toggle-switch" id="plain-mode-toggle" onclick="togglePlainMode()"></div>
                </div>
            </div>

            <!-- 6. GAME INFO -->
            <div class="settings-version">
                Word Boxing v1.0.9<br>
                <span style="font-size: 0.7rem;">Â© 2026 RB Games</span>
            </div>
        </div>
    </div>

    <!-- About Modal -->
    <div class="about-modal" id="about-modal" onclick="closeAboutModal(event)">
        <div class="about-content" onclick="event.stopPropagation()">
            <h2><span class="red">Word</span> <span class="blue">Boxing</span> ðŸ¥Š</h2>
            <div class="about-tagline">A battle of wits and words!</div>
            
            <p class="about-text">
                Word Boxing is a competitive word-guessing game where two players go head-to-head in a battle to crack each other's secret 5-letter words.
            </p>
            
            <p class="about-text">
                Choose your words strategically using rare letters to make your opponent's job harder, then use deduction and word knowledge to solve theirs first!
            </p>
            
            <div class="about-credits">
                Built with â¤ï¸ for word game enthusiasts
            </div>
            
            <!-- Game Shelf Badge -->
            <div style="text-align: center; padding: 20px 15px; background: linear-gradient(135deg, rgba(102,126,234,0.15) 0%, rgba(118,75,162,0.15) 100%); border-radius: 12px; margin-top: 20px;">
                <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 10px;">
                    <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" style="width: 40px; height: 40px;">
                        <defs>
                            <linearGradient id="gsBadgeGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#667eea"/>
                                <stop offset="100%" style="stop-color:#764ba2"/>
                            </linearGradient>
                        </defs>
                        <rect x="5" y="5" width="90" height="90" rx="20" fill="url(#gsBadgeGrad)"/>
                        <g transform="rotate(-12, 35, 50)">
                            <rect x="15" y="28" width="28" height="36" rx="4" fill="white"/>
                            <circle cx="43" cy="46" r="6" fill="white"/>
                            <text x="29" y="54" font-family="Arial, sans-serif" font-size="20" font-weight="bold" fill="#667eea" text-anchor="middle">G</text>
                        </g>
                        <g transform="rotate(12, 65, 50)">
                            <rect x="57" y="28" width="28" height="36" rx="4" fill="rgba(255,255,255,0.9)"/>
                            <circle cx="57" cy="46" r="6" fill="url(#gsBadgeGrad)"/>
                            <text x="71" y="54" font-family="Arial, sans-serif" font-size="20" font-weight="bold" fill="#764ba2" text-anchor="middle">S</text>
                        </g>
                    </svg>
                    <span style="font-size: 1.1rem; font-weight: 600; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">A Game Shelf Original</span>
                </div>
                <p style="font-size: 0.85rem; color: #888; margin: 0;">
                    Track your daily puzzles at <a href="https://gameshelf.club" target="_blank" style="color: #667eea; text-decoration: none; font-weight: 500;">gameshelf.club</a>
                </p>
            </div>
            
            <button class="btn btn-primary" onclick="closeAbout()" style="width: 100%; margin-top: 20px;">Got it!</button>
        </div>
    </div>

    <!-- Game Overview Modal -->
    <div class="overview-modal" id="overview-modal" onclick="closeOverviewModal(event)">
        <div class="overview-content" onclick="event.stopPropagation()">
            <h2>ðŸ“– How to Play</h2>
            
            <div class="overview-section">
                <h3>ðŸŽ¯ Objective</h3>
                <p>Be the first to guess your opponent's secret 5-letter word! Win 2 out of 3 rounds to win the match.</p>
            </div>
            
            <div class="overview-section">
                <h3>âš”ï¸ Gameplay</h3>
                <ul>
                    <li>Each player picks a secret word for their opponent to guess</li>
                    <li>Take turns either <strong>guessing a letter</strong> or <strong>solving the word</strong></li>
                    <li>Correct letter guesses reveal that letter in the word</li>
                    <li>Wrong solve attempts lose the round!</li>
                </ul>
            </div>
            
            <div class="overview-section">
                <h3>ðŸ’¡ Strategy Tips</h3>
                <ul>
                    <li><strong>Word Selection:</strong> Use rare letters (J, Q, X, Z) to make your word harder to guess</li>
                    <li><strong>Letter Guessing:</strong> Start with common letters (E, A, R, S, T) to reveal patterns</li>
                    <li><strong>Timing:</strong> Don't solve too early - wrong guesses lose the round!</li>
                </ul>
            </div>
            
            <div class="overview-section">
                <h3>ðŸŽ® Game Modes</h3>
                <ul>
                    <li><strong>Beginner:</strong> Pick a new word each round</li>
                    <li><strong>Advanced:</strong> Plan all 3 words upfront - no letter can repeat across words!</li>
                </ul>
            </div>
            
            <div class="overview-checkbox">
                <input type="checkbox" id="dont-show-overview" onchange="updateDontShowOverview(this.checked)">
                <label for="dont-show-overview">Don't show this again</label>
            </div>
            
            <button class="btn btn-primary" onclick="closeOverview()" style="width: 100%;">Let's Play!</button>
        </div>
    </div>

    <div class="version">v1.0.9 &bull; Word Boxing</div>

    <script>
        // ============ GAME SHELF INTEGRATION MODULE v1.0.9 ============
        (function() {
            'use strict';
            const GAMESHELF_VERSION = '1.0.9';
            if (window.GameShelfIntegration) return;
            
            window.GameShelfIntegration = {
                version: GAMESHELF_VERSION,
                gameId: null,
                gameConfig: null,
                _initialized: false,
                
                init: function(gameId, config) {
                    if (this._initialized) return;
                    this.gameId = gameId;
                    this.gameConfig = {
                        name: config.name || gameId,
                        icon: config.icon || 'ðŸŽ®',
                        url: config.url || window.location.hostname,
                        version: config.version || '1.0.9',
                        type: config.type || 'daily',
                        ...config
                    };
                    this._initialized = true;
                    this._announcePresence();
                    console.log(`ðŸŽ® Game Shelf Integration initialized for ${this.gameConfig.name}`);
                },
                
                reportComplete: function(result) {
                    if (!this._initialized) return null;
                    const payload = this._buildPayload(result);
                    // Removed: this._storeResult(payload) - copy/paste is now standard
                    this._dispatchEvents(payload);
                    return payload;
                },
                
                _buildPayload: function(result) {
                    return {
                        gameId: this.gameId,
                        gameName: this.gameConfig.name,
                        gameIcon: this.gameConfig.icon,
                        gameUrl: this.gameConfig.url,
                        gameVersion: this.gameConfig.version,
                        timestamp: new Date().toISOString(),
                        date: this._getTodayString(),
                        puzzleId: result.puzzleId || this._getTodayString(),
                        puzzleNumber: result.puzzleNumber || null,
                        result: {
                            won: !!result.won,
                            score: result.score ?? null,
                            attempts: result.attempts ?? null,
                            maxAttempts: result.maxAttempts ?? null,
                            hintsUsed: result.hintsUsed ?? 0,
                            gaveUp: !!result.gaveUp,
                            perfect: !!result.perfect
                        },
                        streak: result.streak || null,
                        meta: {
                            difficulty: result.difficulty ?? null,
                            mode: result.mode ?? null,
                            category: result.category ?? null,
                            ...(result.meta || {})
                        },
                        grid: result.grid || null,
                        scoreLine: result.scoreLine || null,
                        shareText: result.shareText || null
                    };
                },
                
                _announcePresence: function() {
                    document.documentElement.setAttribute('data-gameshelf-game', this.gameId);
                    document.documentElement.setAttribute('data-gameshelf-version', GAMESHELF_VERSION);
                    window.dispatchEvent(new CustomEvent('gameshelf:presence', {
                        detail: { gameId: this.gameId, config: this.gameConfig }
                    }));
                },
                
                _dispatchEvents: function(payload) {
                    window.dispatchEvent(new CustomEvent('gameshelf:complete', { detail: payload }));
                    window.dispatchEvent(new CustomEvent('gameshelf:gameComplete', { detail: payload }));
                },
                
                _storeResult: function(payload) {
                    try {
                        localStorage.setItem(`gameshelf_${this.gameId}_latest`, JSON.stringify(payload));
                        let history = JSON.parse(localStorage.getItem(`gameshelf_${this.gameId}_history`) || '[]');
                        history = history.filter(h => h.puzzleId !== payload.puzzleId);
                        history.unshift(payload);
                        localStorage.setItem(`gameshelf_${this.gameId}_history`, JSON.stringify(history.slice(0, 30)));
                    } catch (e) {}
                },
                
                _getTodayString: function() {
                    const d = new Date();
                    return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
                }
            };
        })();
        // ============ END GAME SHELF INTEGRATION ============

        // Firebase Configuration - Word Boxing Production
        const firebaseConfig = {
            apiKey: "AIzaSyBQVwn8vOrFTzLlm2MYIPBwgZV2xR9AuhM",
            authDomain: "word-boxing.firebaseapp.com",
            databaseURL: "https://word-boxing-default-rtdb.firebaseio.com",
            projectId: "word-boxing",
            storageBucket: "word-boxing.firebasestorage.app",
            messagingSenderId: "300155036194",
            appId: "1:300155036194:web:b35463e6f9fbb04d7fe07b",
            measurementId: "G-XRL2SVN0YF"
        };

        // Initialize Firebase
        let db = null;
        let auth = null;
        let gameRef = null;
        let isFirebaseReady = false;

        // Try to initialize Firebase
        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.database();
            auth = firebase.auth();
            isFirebaseReady = true;
            console.log('Firebase initialized');
        } catch (e) {
            console.warn('Firebase not available, running in demo mode');
            isFirebaseReady = false;
        }

        // ============ USER STATE ============
        
        let currentUser = null;
        
        // Plain Mode - defaults to ON for free tier
        // Plain Mode - defaults to ON for first run (free tier)
        if (localStorage.getItem('wordboxingPlainMode') === null) {
            localStorage.setItem('wordboxingPlainMode', 'true');
        }
        let plainMode = localStorage.getItem('wordboxingPlainMode') === 'true';
        let userProfile = {
            odid: null,
            displayName: 'Guest',
            photoURL: null,
            rating: 1200,
            peakRating: 1200,
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            winStreak: 0,
            bestStreak: 0,
            matchHistory: []
        };

        // ELO Constants
        const ELO_K_FACTOR = 32;
        const ELO_K_PROVISIONAL = 48; // Higher K for first 10 games
        const PROVISIONAL_GAMES = 10;
        const STARTING_RATING = 1200;

        // Rank Tiers
        const RANK_TIERS = [
            { name: 'Rookie', min: 0, max: 999, icon: 'ðŸ¥‰', class: 'rookie' },
            { name: 'Contender', min: 1000, max: 1199, icon: 'ðŸ¥ˆ', class: 'contender' },
            { name: 'Fighter', min: 1200, max: 1399, icon: 'ðŸ¥‡', class: 'fighter' },
            { name: 'Champion', min: 1400, max: 1599, icon: 'ðŸ†', class: 'champion' },
            { name: 'Legend', min: 1600, max: 9999, icon: 'ðŸ‘‘', class: 'legend' }
        ];

        function getRankTier(rating) {
            return RANK_TIERS.find(tier => rating >= tier.min && rating <= tier.max) || RANK_TIERS[0];
        }

        // ============ AUTHENTICATION ============

        function signInWithGoogle() {
            if (!isFirebaseReady || !auth) {
                showMessage('Sign-in not available in demo mode', 'error');
                return;
            }

            const signInBtn = document.getElementById('sign-in-btn');
            LoadingManager.setButtonLoading(signInBtn, true);

            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider)
                .then((result) => {
                    console.log('Signed in:', result.user.displayName);
                    showMessage(`Welcome, ${result.user.displayName}!`, 'success');
                })
                .catch((error) => {
                    console.error('Sign-in error:', error);
                    handleError(error, 'Sign-in');
                })
                .finally(() => {
                    LoadingManager.setButtonLoading(signInBtn, false);
                });
        }

        function signOut() {
            if (auth) {
                auth.signOut().then(() => {
                    showMessage('Signed out', 'info');
                    closeProfile();
                });
            }
        }

        function handleAuthStateChange(user) {
            currentUser = user;
            
            if (user) {
                // User is signed in
                document.getElementById('sign-in-btn').style.display = 'none';
                document.getElementById('user-profile').style.display = 'flex';
                document.getElementById('user-avatar').src = user.photoURL || 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="%23666"/><text x="50" y="65" text-anchor="middle" font-size="40" fill="%23fff">?</text></svg>';
                document.getElementById('user-name').textContent = user.displayName || 'Player';
                
                // Load user profile from database
                loadUserProfile(user.uid);
                
                // Load friends list
                loadFriends();
                
                // Show rated badge on create game (if element exists)
                const ratedBadge = document.getElementById('create-rated-badge');
                if (ratedBadge) ratedBadge.style.display = 'inline-block';
            } else {
                // User is signed out
                document.getElementById('sign-in-btn').style.display = 'flex';
                document.getElementById('user-profile').style.display = 'none';
                
                // Reset to guest profile
                userProfile = {
                    odid: null,
                    displayName: 'Guest',
                    photoURL: null,
                    rating: 1200,
                    peakRating: 1200,
                    gamesPlayed: 0,
                    wins: 0,
                    losses: 0,
                    winStreak: 0,
                    bestStreak: 0,
                    matchHistory: []
                };
                
                // Clear friends list
                friendsList = {};
                
                // Hide rated badge (guests can't play rated)
                const ratedBadge = document.getElementById('create-rated-badge');
                if (ratedBadge) ratedBadge.style.display = 'none';
            }
        }

        async function loadUserProfile(odid) {
            if (!db) return;
            
            try {
                const snapshot = await db.ref('users/' + odid).once('value');
                
                if (snapshot.exists()) {
                    const data = snapshot.val();
                    userProfile = {
                        odid: odid,
                        displayName: data.displayName || currentUser.displayName,
                        photoURL: data.photoURL || currentUser.photoURL,
                        rating: data.rating || STARTING_RATING,
                        peakRating: data.peakRating || STARTING_RATING,
                        gamesPlayed: data.gamesPlayed || 0,
                        wins: data.wins || 0,
                        losses: data.losses || 0,
                        winStreak: data.winStreak || 0,
                        bestStreak: data.bestStreak || 0,
                        matchHistory: data.matchHistory || []
                    };
                } else {
                    // Create new user profile
                    userProfile = {
                        odid: odid,
                        displayName: currentUser.displayName,
                        photoURL: currentUser.photoURL,
                        rating: STARTING_RATING,
                        peakRating: STARTING_RATING,
                        gamesPlayed: 0,
                        wins: 0,
                        losses: 0,
                        winStreak: 0,
                        bestStreak: 0,
                        matchHistory: []
                    };
                    
                    await db.ref('users/' + odid).set(userProfile);
                    
                    // Add to leaderboard with full profile data
                    await db.ref('leaderboard/' + odid).set({
                        odid: odid,
                        displayName: userProfile.displayName,
                        photoURL: userProfile.photoURL,
                        rating: STARTING_RATING,
                        gamesPlayed: 0,
                        wins: 0,
                        losses: 0,
                        lastActive: Date.now()
                    });
                }
                
                // Update UI
                document.getElementById('user-rating').textContent = userProfile.rating;
                
            } catch (error) {
                console.error('Error loading profile:', error);
            }
        }

        async function saveUserProfile() {
            if (!db || !currentUser) return;
            
            try {
                await db.ref('users/' + currentUser.uid).update({
                    displayName: userProfile.displayName,
                    photoURL: userProfile.photoURL,
                    rating: userProfile.rating,
                    peakRating: userProfile.peakRating,
                    gamesPlayed: userProfile.gamesPlayed,
                    wins: userProfile.wins,
                    losses: userProfile.losses,
                    winStreak: userProfile.winStreak,
                    bestStreak: userProfile.bestStreak,
                    matchHistory: userProfile.matchHistory.slice(0, 20) // Keep last 20
                });
                
                // Update leaderboard with full profile data
                await db.ref('leaderboard/' + currentUser.uid).set({
                    odid: currentUser.uid,
                    displayName: userProfile.displayName,
                    photoURL: userProfile.photoURL,
                    rating: userProfile.rating,
                    gamesPlayed: userProfile.gamesPlayed,
                    wins: userProfile.wins,
                    losses: userProfile.losses,
                    lastActive: Date.now()
                });
                
            } catch (error) {
                console.error('Error saving profile:', error);
            }
        }

        // ============ ELO CALCULATIONS ============

        function calculateExpectedScore(myRating, opponentRating) {
            return 1 / (1 + Math.pow(10, (opponentRating - myRating) / 400));
        }

        function calculateNewRating(myRating, opponentRating, won, gamesPlayed) {
            const expected = calculateExpectedScore(myRating, opponentRating);
            const actual = won ? 1 : 0;
            const k = gamesPlayed < PROVISIONAL_GAMES ? ELO_K_PROVISIONAL : ELO_K_FACTOR;
            
            return Math.round(myRating + k * (actual - expected));
        }

        async function recordMatchResult(opponentId, opponentName, opponentRating, won, score) {
            if (!currentUser || passPlayState.active) return; // Don't record pass & play
            
            const oldRating = userProfile.rating;
            const newRating = calculateNewRating(oldRating, opponentRating, won, userProfile.gamesPlayed);
            const ratingChange = newRating - oldRating;
            
            // Update profile
            userProfile.rating = newRating;
            userProfile.gamesPlayed++;
            
            if (won) {
                userProfile.wins++;
                userProfile.winStreak++;
                if (userProfile.winStreak > userProfile.bestStreak) {
                    userProfile.bestStreak = userProfile.winStreak;
                }
            } else {
                userProfile.losses++;
                userProfile.winStreak = 0;
            }
            
            if (newRating > userProfile.peakRating) {
                userProfile.peakRating = newRating;
            }
            
            // Add to match history
            userProfile.matchHistory.unshift({
                odponentId: opponentId,
                opponentName: opponentName,
                opponentRating: opponentRating,
                result: won ? 'win' : 'loss',
                score: score,
                ratingChange: ratingChange,
                timestamp: Date.now()
            });
            
            // Keep only last 20 matches
            if (userProfile.matchHistory.length > 20) {
                userProfile.matchHistory = userProfile.matchHistory.slice(0, 20);
            }
            
            // Update UI
            document.getElementById('user-rating').textContent = userProfile.rating;
            
            // Save to database
            await saveUserProfile();
            
            // Show rating change
            const changeText = ratingChange >= 0 ? `+${ratingChange}` : `${ratingChange}`;
            showMessage(`Rating: ${oldRating} â†’ ${newRating} (${changeText})`, ratingChange >= 0 ? 'success' : 'error');
        }

        // ============ PROFILE MODAL ============

        function showProfile() {
            if (!currentUser) return;
            
            const modal = document.getElementById('profile-modal');
            modal.classList.add('active');
            
            // Fill profile data
            document.getElementById('profile-avatar').src = userProfile.photoURL || currentUser.photoURL || '';
            document.getElementById('profile-name').textContent = userProfile.displayName;
            document.getElementById('profile-rating').textContent = userProfile.rating;
            document.getElementById('profile-peak-rating').textContent = userProfile.peakRating;
            document.getElementById('profile-wins').textContent = userProfile.wins;
            document.getElementById('profile-losses').textContent = userProfile.losses;
            document.getElementById('profile-streak').textContent = userProfile.winStreak;
            
            // Rank badge
            const tier = getRankTier(userProfile.rating);
            document.getElementById('profile-rank-badge').innerHTML = `<span class="rank-badge ${tier.class}">${tier.icon} ${tier.name}</span>`;
            
            // Match history
            const historyEl = document.getElementById('match-history-list');
            if (userProfile.matchHistory.length === 0) {
                historyEl.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No matches yet</p>';
            } else {
                historyEl.innerHTML = userProfile.matchHistory.slice(0, 10).map(match => `
                    <div class="match-item">
                        <span class="match-opponent">${match.opponentName}</span>
                        <span class="match-result ${match.result}">${match.result.toUpperCase()} ${match.score}</span>
                        <span class="match-rating-change ${match.ratingChange >= 0 ? 'positive' : 'negative'}">
                            ${match.ratingChange >= 0 ? '+' : ''}${match.ratingChange}
                        </span>
                    </div>
                `).join('');
            }
            
            // Reset to matches tab and load friends
            showProfileTab('matches');
            loadFriends();
        }

        function closeProfile() {
            document.getElementById('profile-modal').classList.remove('active');
        }

        function closeProfileModal(event) {
            if (event.target.id === 'profile-modal') {
                closeProfile();
            }
        }

        // ============ FRIENDS SYSTEM ============

        let friendsList = {}; // Cache of friends {odid: {displayName, rating, addedAt}}
        let leaderboardFilter = 'all'; // 'all' or 'friends'

        async function loadFriends() {
            if (!currentUser || !db) {
                document.getElementById('friends-count').textContent = '0';
                return;
            }
            
            try {
                const snapshot = await db.ref('friends/' + currentUser.uid).once('value');
                friendsList = snapshot.val() || {};
                
                const count = Object.keys(friendsList).length;
                document.getElementById('friends-count').textContent = count;
                
                // Update friends list UI
                const friendsListEl = document.getElementById('friends-list');
                if (count === 0) {
                    friendsListEl.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">No friends yet. Add friends after matches!</p>';
                } else {
                    // Fetch current ratings from leaderboard for each friend
                    const friendEntries = await Promise.all(
                        Object.entries(friendsList).map(async ([odid, data]) => {
                            // Try to get current rating from leaderboard
                            try {
                                const ratingSnap = await db.ref('leaderboard/' + odid + '/rating').once('value');
                                const currentRating = ratingSnap.val() || data.rating || 1200;
                                return { odid, ...data, rating: currentRating };
                            } catch {
                                return { odid, ...data };
                            }
                        })
                    );
                    
                    // Sort by rating descending
                    friendEntries.sort((a, b) => (b.rating || 1200) - (a.rating || 1200));
                    
                    friendsListEl.innerHTML = friendEntries.map(friend => `
                        <div class="friend-item">
                            <div class="friend-info">
                                <span class="friend-name">${friend.displayName || 'Player'}</span>
                                <span class="friend-rating">${friend.rating || 1200}</span>
                            </div>
                            <button class="friend-remove" onclick="removeFriend('${friend.odid}')" title="Remove friend">Ã—</button>
                        </div>
                    `).join('');
                }
            } catch (error) {
                console.error('Error loading friends:', error);
            }
        }

        async function addFriend(odid, displayName, rating) {
            if (!currentUser || !db) {
                showMessage('Sign in to add friends', 'error');
                return false;
            }
            
            if (odid === currentUser.uid) {
                showMessage("You can't add yourself as a friend", 'error');
                return false;
            }
            
            try {
                await db.ref('friends/' + currentUser.uid + '/' + odid).set({
                    odid: odid,
                    displayName: displayName,
                    rating: rating,
                    addedAt: firebase.database.ServerValue.TIMESTAMP
                });
                
                // Update local cache
                friendsList[odid] = { odid, displayName, rating, addedAt: Date.now() };
                document.getElementById('friends-count').textContent = Object.keys(friendsList).length;
                
                showMessage(`Added ${displayName} as friend!`, 'success');
                return true;
            } catch (error) {
                console.error('Error adding friend:', error);
                showMessage('Failed to add friend', 'error');
                return false;
            }
        }

        async function removeFriend(odid) {
            if (!currentUser || !db) return;
            
            const friendName = friendsList[odid]?.displayName || 'Friend';
            
            try {
                await db.ref('friends/' + currentUser.uid + '/' + odid).remove();
                
                // Update local cache
                delete friendsList[odid];
                document.getElementById('friends-count').textContent = Object.keys(friendsList).length;
                
                // Refresh friends list UI
                loadFriends();
                
                showMessage(`Removed ${friendName} from friends`, 'info');
            } catch (error) {
                console.error('Error removing friend:', error);
                showMessage('Failed to remove friend', 'error');
            }
        }

        function isFriend(odid) {
            return friendsList.hasOwnProperty(odid);
        }

        async function toggleFriend() {
            if (!currentUser) {
                showMessage('Sign in to add friends', 'error');
                return;
            }
            
            const opponentId = gameState.opponentUserId;
            const opponentName = gameState.opponentDisplayName;
            const opponentRating = gameState.opponentUserRating;
            
            if (!opponentId) {
                showMessage('Cannot add guest as friend', 'error');
                return;
            }
            
            const btn = document.getElementById('add-friend-btn');
            
            if (isFriend(opponentId)) {
                // Remove friend
                await removeFriend(opponentId);
                btn.textContent = 'ðŸ‘¤ Add Friend';
                btn.classList.remove('friend-added');
            } else {
                // Add friend
                const success = await addFriend(opponentId, opponentName, opponentRating);
                if (success) {
                    btn.textContent = 'âœ“ Friends';
                    btn.classList.add('friend-added');
                }
            }
        }

        function updateAddFriendButton() {
            const container = document.getElementById('add-friend-container');
            const btn = document.getElementById('add-friend-btn');
            
            // Only show for online games with signed-in users
            if (!currentUser || passPlayState.active || !gameState.opponentUserId) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            
            if (isFriend(gameState.opponentUserId)) {
                btn.textContent = 'âœ“ Friends';
                btn.classList.add('friend-added');
            } else {
                btn.textContent = 'ðŸ‘¤ Add Friend';
                btn.classList.remove('friend-added');
            }
        }

        function showProfileTab(tab) {
            const matchesSection = document.getElementById('profile-matches-section');
            const friendsSection = document.getElementById('profile-friends-section');
            const tabMatches = document.getElementById('tab-matches');
            const tabFriends = document.getElementById('tab-friends');
            
            if (tab === 'matches') {
                matchesSection.style.display = 'block';
                friendsSection.style.display = 'none';
                tabMatches.classList.add('active');
                tabFriends.classList.remove('active');
            } else {
                matchesSection.style.display = 'none';
                friendsSection.style.display = 'block';
                tabMatches.classList.remove('active');
                tabFriends.classList.add('active');
            }
        }

        function setLeaderboardFilter(filter) {
            leaderboardFilter = filter;
            
            // Update button states
            document.getElementById('filter-all').classList.toggle('active', filter === 'all');
            document.getElementById('filter-friends').classList.toggle('active', filter === 'friends');
            
            // Refresh leaderboard
            showLeaderboard();
        }

        // ============ LEADERBOARD ============

        async function showLeaderboard() {
            const modal = document.getElementById('leaderboard-modal');
            modal.classList.add('active');

            const listEl = document.getElementById('leaderboard-list');
            // Show skeleton loading
            LoadingManager.showSkeleton(listEl, 5);

            if (!db) {
                listEl.innerHTML = '<li style="color: #666; text-align: center; padding: 20px;">Leaderboard unavailable in demo mode</li>';
                return;
            }
            
            // Load friends list if needed for filtering
            if (leaderboardFilter === 'friends' && Object.keys(friendsList).length === 0) {
                await loadFriends();
            }
            
            try {
                // Get top 50 from leaderboard (ordered by rating)
                const snapshot = await db.ref('leaderboard')
                    .orderByChild('rating')
                    .limitToLast(100) // Get more to allow filtering
                    .once('value');
                
                let leaderboardData = [];
                snapshot.forEach((child) => {
                    const data = child.val();
                    // Handle both old format (just rating number) and new format (full object)
                    if (typeof data === 'number') {
                        leaderboardData.push({
                            odid: child.key,
                            displayName: 'Player',
                            photoURL: '',
                            rating: data,
                            wins: 0,
                            losses: 0
                        });
                    } else {
                        leaderboardData.push({
                            odid: child.key,
                            displayName: data.displayName || 'Player',
                            photoURL: data.photoURL || '',
                            rating: data.rating || 1200,
                            wins: data.wins || 0,
                            losses: data.losses || 0
                        });
                    }
                });
                
                // Sort descending by rating
                leaderboardData.sort((a, b) => b.rating - a.rating);
                
                // Filter by friends if needed
                if (leaderboardFilter === 'friends') {
                    const friendIds = Object.keys(friendsList);
                    // Include self and friends
                    leaderboardData = leaderboardData.filter(entry => 
                        friendIds.includes(entry.odid) || (currentUser && entry.odid === currentUser.uid)
                    );
                    
                    if (leaderboardData.length === 0) {
                        listEl.innerHTML = '<li style="color: #666; text-align: center; padding: 20px;">No friends yet. Add friends after matches!</li>';
                        return;
                    }
                } else {
                    // Limit to top 50 for all players view
                    leaderboardData = leaderboardData.slice(0, 50);
                }
                
                if (leaderboardData.length === 0) {
                    listEl.innerHTML = '<li style="color: #666; text-align: center; padding: 20px;">No players yet. Be the first!</li>';
                    return;
                }
                
                // Check if current user is in the list
                let userInList = false;
                let userRank = -1;
                
                if (currentUser) {
                    userRank = leaderboardData.findIndex(e => e.odid === currentUser.uid);
                    userInList = userRank !== -1;
                }
                
                // Build leaderboard HTML
                const defaultAvatar = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="50" fill="%23666"/></svg>';
                
                let html = leaderboardData.map((entry, index) => {
                    const isMe = currentUser && entry.odid === currentUser.uid;
                    const isFriendEntry = isFriend(entry.odid);
                    const tier = getRankTier(entry.rating);
                    const rankDisplay = index < 3 ? ['ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰'][index] : (index + 1);
                    const record = `${entry.wins}-${entry.losses}`;
                    const friendIcon = isFriendEntry ? ' ðŸ‘¤' : '';
                    
                    return `
                        <li class="leaderboard-item ${isMe ? 'me' : ''} ${isFriendEntry ? 'friend' : ''}">
                            <span class="leaderboard-rank ${index < 3 ? 'top-3' : ''}">${rankDisplay}</span>
                            <img class="leaderboard-avatar" src="${entry.photoURL || defaultAvatar}" alt="">
                            <span class="leaderboard-name">${entry.displayName}${isMe ? ' (You)' : ''}${friendIcon}</span>
                            <span class="leaderboard-record">${record}</span>
                            <span class="leaderboard-rating">${entry.rating}</span>
                        </li>
                    `;
                }).join('');
                
                // If user is signed in but not in the list (only for 'all' filter)
                if (leaderboardFilter === 'all' && currentUser && !userInList) {
                    // Get all players to find user's rank
                    const allSnapshot = await db.ref('leaderboard')
                        .orderByChild('rating')
                        .once('value');
                    
                    const allPlayers = [];
                    allSnapshot.forEach((child) => {
                        const data = child.val();
                        const rating = typeof data === 'number' ? data : (data.rating || 1200);
                        allPlayers.push({ odid: child.key, rating });
                    });
                    
                    allPlayers.sort((a, b) => b.rating - a.rating);
                    const myRank = allPlayers.findIndex(e => e.odid === currentUser.uid);
                    
                    if (myRank !== -1) {
                        const tier = getRankTier(userProfile.rating);
                        const record = `${userProfile.wins}-${userProfile.losses}`;
                        
                        html += `
                            <li class="leaderboard-divider-line"></li>
                            <li class="leaderboard-item me">
                                <span class="leaderboard-rank">${myRank + 1}</span>
                                <img class="leaderboard-avatar" src="${userProfile.photoURL || defaultAvatar}" alt="">
                                <span class="leaderboard-name">${userProfile.displayName} (You)</span>
                                <span class="leaderboard-record">${record}</span>
                                <span class="leaderboard-rating">${userProfile.rating}</span>
                            </li>
                        `;
                    }
                }
                
                listEl.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                listEl.innerHTML = '<li style="color: #666; text-align: center; padding: 20px;">Error loading leaderboard</li>';
            }
        }

        function closeLeaderboard() {
            document.getElementById('leaderboard-modal').classList.remove('active');
        }

        function closeLeaderboardModal(event) {
            if (event.target.id === 'leaderboard-modal') {
                closeLeaderboard();
            }
        }

        // ============ DEVICE ID (for non-authenticated games) ============

        // Generate device ID for this session
        const deviceId = localStorage.getItem('wordboxing_device_id') || generateDeviceId();
        localStorage.setItem('wordboxing_device_id', deviceId);

        function generateDeviceId() {
            return 'dev_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
        }

        // Game State
        let gameState = {
            gameCode: null,
            myRole: null, // 'red' or 'blue'
            mode: 'beginner',
            status: 'lobby', // 'lobby', 'waiting', 'setup', 'battle', 'finished'
            round: 1,
            myWord: '',
            opponentWord: '',
            myScore: 0,
            opponentScore: 0,
            myWins: 0,
            opponentWins: 0,
            currentTurn: null,
            myRevealed: [false, false, false, false, false], // What I've revealed in opponent's word
            opponentRevealed: [false, false, false, false, false], // What opponent has revealed in MY word
            myGuessedLetters: new Set(),
            isMyTurn: false,
            showingRoundResult: false, // Prevents new round detection while showing result
            processingGuess: false, // Prevents double-submission during wrong guess delay
            submittingPlan: false, // Prevents double-submission of advanced mode plan
            // Advanced mode
            myPlannedWords: ['', '', ''],
            opponentPlannedWords: ['', '', ''],
            // Opponent info for rated games
            opponentUserId: null,
            opponentDisplayName: 'Opponent',
            opponentUserRating: 1200,
            isRatedGame: false,
            isPublic: false
        };

        // Word list for validation (subset for demo)
        const VALID_WORDS = new Set("ABACK,ABASE,ABATE,ABBEY,ABBOT,ABHOR,ABIDE,ABLED,ABODE,ABORT,ABOUT,ABOVE,ABUSE,ABYSS,ACORN,ACRID,ACTOR,ACUTE,ADAGE,ADAPT,ADDAX,ADDED,ADDER,ADDLE,ADEPT,ADMIN,ADMIT,ADOBE,ADOPT,ADORE,ADORN,ADULT,AFFIX,AFIRE,AFOOT,AFOUL,AFTER,AGAIN,AGAPE,AGATE,AGENT,AGILE,AGING,AGLOW,AGONY,AGREE,AHEAD,AIDER,AISLE,ALARM,ALBUM,ALERT,ALGAE,ALIBI,ALIEN,ALIGN,ALIKE,ALIVE,ALLAY,ALLEY,ALLOT,ALLOW,ALLOY,ALOFT,ALONE,ALONG,ALOOF,ALOUD,ALPHA,ALTAR,ALTER,AMASS,AMAZE,AMBER,AMBLE,AMEND,AMISS,AMITY,AMONG,AMPLE,AMPLY,AMUSE,ANGEL,ANGER,ANGLE,ANGRY,ANGST,ANIME,ANKLE,ANNEX,ANNOY,ANNUL,ANODE,ANTIC,ANVIL,AORTA,APART,APHID,APING,APNEA,APPLE,APPLY,APRON,APTLY,ARBOR,ARDOR,ARENA,ARGUE,ARISE,ARMOR,AROMA,AROSE,ARRAY,ARROW,ARSON,ARTSY,ASCOT,ASHEN,ASIDE,ASKEW,ASSAY,ASSET,ATOLL,ATONE,ATTIC,AUDIO,AUDIT,AUGUR,AUNTY,AVAIL,AVERT,AVIAN,AVOID,AWAIT,AWAKE,AWARD,AWARE,AWASH,AWFUL,AWOKE,AXIAL,AXIOM,AXION,AZTEC,BABEL,BACCY,BACON,BADGE,BADLY,BAGEL,BAGGY,BAKER,BALER,BALKY,BALLS,BALMY,BANAL,BANDY,BANES,BANJO,BANKS,BARBS,BARDS,BARED,BARER,BARES,BARFS,BARGE,BARKS,BARMY,BARNS,BARON,BASAL,BASED,BASER,BASES,BASIC,BASIL,BASIN,BASIS,BASKS,BASTE,BATCH,BATED,BATHS,BATON,BATTY,BAULK,BAWDY,BAWLS,BAYOU,BEACH,BEADS,BEADY,BEAKS,BEAMS,BEAMY,BEANS,BEARD,BEARS,BEAST,BEATS,BEAUS,BEAUT,BEBOP,BECKS,BEECH,BEEFS,BEEFY,BEEPS,BEERS,BEERY,BEETS,BEFIT,BEGAN,BEGAT,BEGET,BEGIN,BEGOT,BEGUN,BEING,BELAY,BELCH,BELIE,BELLE,BELLS,BELLY,BELOW,BELTS,BENCH,BENDS,BENDY,BENNE,BENTO,BERET,BERRY,BERTH,BESET,BESOT,BESTS,BETAS,BETEL,BEVEL,BEVVY,BIBLE,BICEP,BIDDY,BIDED,BIDER,BIDES,BIDET,BIDIS,BIFFY,BIFID,BIGGY,BIGOT,BIKED,BIKER,BIKES,BILGE,BILGY,BILKS,BILLS,BILLY,BIMBO,BINGE,BINGO,BIOME,BIOTA,BIPOD,BIRCH,BIRDS,BIRTH,BISON,BITCH,BITER,BITES,BITSY,BITTY,BLACK,BLADE,BLAME,BLAND,BLANK,BLARE,BLASE,BLAST,BLAZE,BLEAK,BLEAT,BLEED,BLEEP,BLEND,BLESS,BLIMP,BLIND,BLING,BLINI,BLINK,BLIPS,BLISS,BLITZ,BLOAT,BLOBS,BLOCK,BLOKE,BLOND,BLOOD,BLOOM,BLOWN,BLOWS,BLOWY,BLUED,BLUER,BLUES,BLUEY,BLUFF,BLUME,BLUNT,BLURB,BLURS,BLURT,BLUSH,BOARD,BOARS,BOAST,BOATS,BOBBY,BOCCE,BODED,BODES,BODGE,BOGEY,BOGGY,BOGIE,BOGUS,BOILS,BOLAS,BOLDS,BOLLS,BOLTS,BOMBE,BOMBS,BONDS,BONED,BONER,BONES,BONEY,BONGO,BONKS,BONNY,BONUS,BOOBS,BOOBY,BOOED,BOOKS,BOOMS,BOOMY,BOONS,BOORS,BOOST,BOOTH,BOOTS,BOOTY,BOOZE,BOOZY,BORAX,BORED,BORER,BORES,BORNE,BORON,BOSOM,BOSSY,BOTCH,BOUGH,BOUND,BOUTS,BOWED,BOWEL,BOWER,BOWLS,BOXED,BOXER,BOXES,BRACE,BRACT,BRAGS,BRAID,BRAIN,BRAKE,BRAND,BRASH,BRASS,BRATS,BRAVE,BRAVO,BRAWL,BRAWN,BRAYS,BREAD,BREAK,BREAM,BREED,BREWS,BRIAR,BRIBE,BRICK,BRIDE,BRIEF,BRIER,BRINE,BRING,BRINK,BRINY,BRISK,BROAD,BROIL,BROKE,BROOD,BROOK,BROOM,BROTH,BROWN,BROWS,BRUIN,BRUNT,BRUSH,BRUTE,BUDDY,BUDGE,BUGGY,BUGLE,BUILD,BUILT,BULBS,BULGE,BULGY,BULKS,BULKY,BULLA,BULLS,BULLY,BUMPS,BUMPY,BUNCH,BUNCO,BUNKS,BUNNY,BUNTS,BUOYS,BURGH,BURGS,BURKA,BURKE,BURLY,BURNS,BURNT,BURPS,BURRO,BURRS,BURST,BUSBY,BUSHY,BUSKS,BUSTS,BUSTY,BUTCH,BUTTE,BUTTS,BUXOM,BUYER,BYLAW,BYTES,CABAL,CABBY,CABIN,CABLE,CACAO,CACHE,CACTI,CADDY,CADET,CADGE,CAFES,CAGED,CAGER,CAGES,CAGEY,CAIRN,CAKED,CAKES,CAMEL,CAMEO,CAMPO,CAMPS,CAMPY,CANAL,CANDY,CANED,CANER,CANES,CANID,CANNY,CANOE,CANON,CAPED,CAPER,CAPES,CAPOS,CARDS,CARED,CARER,CARES,CARGO,CAROB,CAROL,CAROM,CARPS,CARRY,CARTS,CARVE,CASAS,CASED,CASES,CASKS,CASTE,CASTS,CATCH,CATER,CATTY,CAULK,CAUSE,CAVES,CAVIL,CEASE,CEDAR,CEDED,CEDES,CELEB,CELLO,CELLS,CHAFE,CHAFF,CHAIN,CHAIR,CHALK,CHAMP,CHAMS,CHANT,CHAOS,CHAPS,CHARD,CHARM,CHARS,CHART,CHASE,CHASM,CHEAP,CHEAT,CHECK,CHEEK,CHEEP,CHEER,CHESS,CHEST,CHEWS,CHEWY,CHICK,CHIDE,CHIEF,CHILD,CHILE,CHILI,CHILL,CHIMP,CHINA,CHINS,CHIPS,CHIRP,CHIVE,CHOIR,CHOKE,CHOMP,CHOPS,CHORD,CHORE,CHOSE,CHUCK,CHUMP,CHUMS,CHUNK,CHURN,CHUTE,CIDER,CIGAR,CINCH,CIRCA,CISCO,CISSY,CITED,CITES,CIVET,CIVIC,CIVIL,CLACK,CLADS,CLAIM,CLAMP,CLAMS,CLANG,CLANK,CLANS,CLAPS,CLASH,CLASP,CLASS,CLAWS,CLAYS,CLEAN,CLEAR,CLEAT,CLEFT,CLERK,CLICK,CLIFF,CLIMB,CLINE,CLING,CLINK,CLIPS,CLOAK,CLOCK,CLODS,CLOGS,CLONE,CLOPS,CLOSE,CLOTH,CLOTS,CLOUD,CLOUT,CLOVE,CLOWN,CLUBS,CLUCK,CLUED,CLUES,CLUMP,CLUNG,CLUNK,COACH,COALS,COAST,COATS,COCOA,COCOS,CODED,CODER,CODES,CODEX,COEDS,COIFS,COILS,COINS,COKED,COKES,COLAS,COLDS,COLON,COLOR,COLTS,COMAS,COMBO,COMBS,COMER,COMES,COMET,COMFY,COMIC,COMMA,CONCH,CONDO,CONED,CONES,CONGA,CONIC,CONKS,COOED,COOKS,COOKY,COOLS,COOPS,COOTS,COPED,COPER,COPES,COPRA,COPSE,CORAL,CORDS,CORED,CORER,CORES,CORGI,CORKS,CORKY,CORNS,CORNY,CORPS,COSTS,COUCH,COUGH,COULD,COUNT,COUPE,COUPS,COURT,COUTH,COVED,COVEN,COVER,COVES,COVET,COVEY,COWED,COWER,COWLS,COYLY,COZEN,CRABS,CRACK,CRAFT,CRAGS,CRAMP,CRAMS,CRANE,CRANK,CRAPE,CRAPS,CRASH,CRASS,CRATE,CRAVE,CRAWL,CRAWS,CRAZE,CRAZY,CREAK,CREAM,CREDO,CREED,CREEK,CREEP,CREME,CREPE,CREPT,CRESS,CREST,CREWS,CRIBS,CRICK,CRIED,CRIER,CRIES,CRIME,CRIMP,CRISP,CROAK,CROCK,CROCS,CRONE,CRONY,CROOK,CROON,CROPS,CROSS,CROUP,CROWD,CROWN,CROWS,CRUDE,CRUEL,CRUET,CRUMB,CRUMP,CRUSH,CRUST,CRYPT,CUBED,CUBER,CUBES,CUBIC,CUBIT,CUFFS,CULLS,CULPA,CULTS,CUMIN,CUNTS,CUPID,CUPPA,CURBS,CURDS,CURDY,CURED,CURER,CURES,CURIO,CURLS,CURLY,CURRY,CURSE,CURVE,CURVY,CUSHY,CUSPS,CUTIE,CUTUP,CYCLE,CYNIC,DADDY,DAILY,DAIRY,DAISY,DALLY,DANCE,DANDY,DATUM,DAUNT,DEALS,DEALT,DEATH,DEBIT,DEBUG,DEBUT,DECAL,DECAY,DECOR,DECOY,DECRY,DEFER,DEITY,DELAY,DELTA,DELVE,DEMON,DEMUR,DENIM,DENSE,DEPOT,DEPTH,DERBY,DESKS,DETER,DETOX,DEUCE,DEVIL,DIARY,DICEY,DIGIT,DILLY,DIMLY,DINER,DINES,DINGY,DIODE,DIRGE,DIRTY,DISCO,DITCH,DITTO,DITTY,DIVAN,DIVER,DIZZY,DODGE,DODGY,DOGMA,DOING,DOLLY,DONOR,DONUT,DOPEY,DOUBT,DOUGH,DOUSE,DOWDY,DOWEL,DRAFT,DRAIN,DRAKE,DRAMA,DRANK,DRAPE,DRAWL,DRAWN,DRAWS,DREAD,DREAM,DRESS,DRIED,DRIER,DRIFT,DRILL,DRINK,DRIVE,DROIT,DROLL,DRONE,DROOL,DROOP,DROSS,DROVE,DROWN,DRUGS,DRUID,DRUMS,DRUNK,DRYER,DRYLY,DUCAL,DUCKS,DUCKY,DUCTS,DUDDY,DUDES,DUELS,DUETS,DUKED,DUKES,DULLS,DULLY,DUMMY,DUMPS,DUMPY,DUNCE,DUNES,DUNKS,DUPED,DUPER,DUPES,DURAL,DUSTY,DUTCH,DUVET,DWARF,DWELL,DWELT,DYING,EAGER,EAGLE,EARED,EARLY,EARTH,EASED,EASEL,EATER,EAVES,EBBED,EBONY,EDGED,EDGER,EDGES,EDICT,EDIFY,EIGHT,EJECT,ELATE,ELBOW,ELDER,ELECT,ELEGY,ELFIN,ELIDE,ELITE,ELOPE,ELUDE,ELVES,EMAIL,EMBED,EMBER,EMCEE,EMERY,EMPTY,ENACT,ENDED,ENDOW,ENEMY,ENJOY,ENNUI,ENTER,ENTRY,ENVOY,EPOCH,EPOXY,EQUAL,EQUIP,ERASE,ERECT,ERODE,ERROR,ERUPT,ESSAY,ETHER,ETHIC,ETHOS,EVADE,EVENT,EVERY,EVICT,EVOKE,EXACT,EXALT,EXCEL,EXERT,EXILE,EXIST,EXPAT,EXPEL,EXTOL,EXTRA,EXUDE,EXULT,EYING,FABLE,FACED,FACER,FACES,FACET,FACTO,FACTS,FADDY,FADED,FADER,FADES,FAGOT,FAILS,FAINT,FAIRY,FAITH,FAKED,FAKER,FAKES,FALLS,FALSE,FAMED,FANCY,FANGS,FANNY,FARCE,FARMS,FATAL,FATTY,FAULT,FAUNA,FAVOR,FEAST,FEATS,FECAL,FECES,FEEDS,FEELS,FEIGN,FEINT,FELLA,FELON,FEMUR,FENCE,FENDS,FERAL,FERNY,FERRY,FETAL,FETCH,FETID,FETUS,FEVER,FEWER,FIBER,FIBRE,FICUS,FIELD,FIEND,FIERY,FIFES,FIFTH,FIFTY,FIGHT,FILCH,FILED,FILER,FILES,FILET,FILLS,FILLY,FILMS,FILMY,FILTH,FINAL,FINCH,FINDS,FINED,FINER,FINES,FINIS,FIRED,FIRER,FIRES,FIRMS,FIRST,FISHY,FISTS,FITLY,FIVER,FIVES,FIXED,FIXER,FIXES,FIZZY,FJORD,FLACK,FLAGS,FLAIR,FLAKE,FLAKY,FLAME,FLANK,FLANS,FLAPS,FLARE,FLASH,FLASK,FLATS,FLAWS,FLEAS,FLECK,FLESH,FLICK,FLIED,FLIER,FLIES,FLING,FLINT,FLIPS,FLIRT,FLOAT,FLOCK,FLOOD,FLOOR,FLORA,FLOSS,FLOUR,FLOUT,FLOWS,FLUID,FLUKE,FLUKY,FLUNG,FLUNK,FLUSH,FLUTE,FOAMY,FOCAL,FOCUS,FOGGY,FOILS,FOIST,FOLKS,FOLLY,FONTS,FOODS,FOOLS,FORAY,FORCE,FORGE,FORGO,FORKS,FORMS,FORTE,FORTH,FORTY,FORUM,FOUND,FOUNT,FOURS,FOWLS,FOXES,FOYER,FRAIL,FRAME,FRANK,FRAUD,FRAYS,FREAK,FREED,FRESH,FRIAR,FRIED,FRIES,FRILL,FRISK,FRIZZ,FROCK,FROGS,FRONT,FROST,FROTH,FROWN,FROZE,FRUIT,FRUMP,FUDGE,FUELS,FUGUE,FULLY,FUMED,FUMES,FUNDS,FUNGI,FUNKY,FUNNY,FURRY,FUSSY,FUSTY,FUZZY,GAILY,GAINS,GAITS,GALES,GALLS,GAMES,GAMMA,GAMUT,GANGS,GAPED,GAPES,GARBS,GASES,GASPS,GASSY,GATES,GAUGE,GAUNT,GAUZE,GAUZY,GAVEL,GAWKS,GAWKY,GAYER,GAYLY,GAZED,GAZER,GAZES,GEARS,GECKO,GEEKS,GEEKY,GEESE,GENIE,GENRE,GENUS,GERMS,GETUP,GHOST,GIANT,GIFTS,GILDS,GILLS,GILTS,GIMPY,GIRDS,GIRLS,GIRLY,GIRTH,GISTS,GIVEN,GIVER,GIVES,GIZMO,GLADE,GLAND,GLARE,GLASS,GLAZE,GLEAM,GLEAN,GLEBE,GLEES,GLENS,GLIDE,GLINT,GLITZ,GLOAT,GLOBE,GLOBS,GLOOM,GLORY,GLOSS,GLOVE,GLOWS,GLUED,GLUER,GLUES,GLUEY,GLUGS,GLUTS,GLYPH,GNARL,GNARS,GNASH,GNATS,GNAWS,GNOME,GOADS,GOALS,GOATS,GODLY,GOERS,GOFER,GOING,GOLDS,GOLFS,GONER,GONGS,GONNA,GOODS,GOODY,GOOEY,GOOFS,GOOFY,GOONS,GOOSE,GORED,GORES,GORGE,GOUGE,GOURD,GOUTS,GOWNS,GRACE,GRADE,GRAFT,GRAIL,GRAIN,GRAMS,GRAND,GRANT,GRAPE,GRAPH,GRASP,GRASS,GRATE,GRAVE,GRAVY,GRAYS,GRAZE,GREAT,GREED,GREEK,GREEN,GREET,GREYS,GRIEF,GRILL,GRIME,GRIMY,GRIND,GRINS,GRIPE,GRIPS,GRIST,GRITS,GROAN,GROAT,GROIN,GROOM,GROPE,GROSS,GROUP,GROUT,GROVE,GROWL,GROWN,GROWS,GRUBS,GRUEL,GRUFF,GRUMP,GRUNT,GUANO,GUARD,GUAVA,GUESS,GUEST,GUIDE,GUILD,GUILT,GUISE,GULCH,GULFS,GULLS,GULPS,GUMMY,GUMPS,GUNKS,GUNKY,GUNNY,GUSTO,GUSTS,GUSTY,GUTSY,GYPSY,HABIT,HACKS,HADES,HADJI,HAFTS,HAIKU,HAILS,HAIRS,HAIRY,HAJJI,HALED,HALER,HALES,HALLS,HALOS,HALTS,HALVE,HANDS,HANDY,HANGS,HANKS,HAPPY,HARDY,HAREM,HARKS,HARMS,HARPS,HARPY,HARRY,HARSH,HASTE,HASTY,HATCH,HATED,HATER,HATES,HAULS,HAUNT,HAVEN,HAVES,HAVOC,HAWKS,HAZED,HAZEL,HAZER,HAZES,HEADS,HEADY,HEALS,HEAPS,HEARD,HEARS,HEART,HEATH,HEATS,HEAVE,HEAVY,HEDGE,HEEDS,HEELS,HEFTS,HEFTY,HEIRS,HEIST,HELIX,HELLO,HELLS,HELPS,HENCE,HENNA,HERBS,HERDS,HERON,HERTZ,HEWED,HEWER,HEXED,HEXES,HICKS,HIDES,HIGHS,HIKED,HIKER,HIKES,HILLS,HILLY,HILTS,HINDS,HINGE,HINTS,HIPPO,HIPPY,HIRED,HIRER,HIRES,HITCH,HIVED,HIVES,HOARD,HOARS,HOARY,HOBBY,HOBOS,HOCKS,HOCUS,HOIST,HOLDS,HOLED,HOLES,HOLEY,HOLLY,HOMED,HOMER,HOMES,HOMEY,HOMIE,HONED,HONER,HONES,HONEY,HONKS,HONOR,HOODS,HOOFS,HOOKS,HOOKY,HOOPS,HOOTS,HOPED,HOPER,HOPES,HORDE,HORNS,HORNY,HORSE,HORSY,HOSED,HOSES,HOTEL,HOTLY,HOUND,HOURS,HOUSE,HOVEL,HOVER,HOWDY,HOWLS,HUBBY,HUFFS,HUFFY,HUGER,HULKS,HULKY,HULLS,HUMAN,HUMID,HUMPS,HUMPY,HUMUS,HUNCH,HUNKS,HUNKY,HUNTS,HURLS,HURRY,HURTS,HUSKS,HUSKY,HUSSY,HUTCH,HYDRA,HYENA,HYMEN,HYMNS,HYPER,ICIER,ICILY,ICING,ICONS,IDEAL,IDEAS,IDIOM,IDIOT,IDLED,IDLER,IDLES,IDOLS,IGLOE,IGLOO,IMAGE,IMBUE,IMPEL,IMPLY,INANE,INAPT,INCUR,INDEX,INDIE,INEPT,INERT,INFER,INGLE,INGOT,INKED,INLAY,INLET,INNER,INPUT,INTER,INTRO,IONIC,IRATE,IRKED,IRONS,IRONY,ISLES,ISLET,ISSUE,ITCHY,ITEMS,IVIED,IVIES,IVORY,JACKS,JADED,JADES,JAFFA,JAGER,JAILS,JAMBS,JAMES,JAMMY,JANES,JANKY,JAPAN,JAPED,JAPER,JAPES,JATOS,JAUNT,JAZZY,JEANS,JEEPS,JEERS,JELLO,JELLY,JENNY,JERKS,JERKY,JESTS,JESUS,JETTY,JEWEL,JIBED,JIBER,JIBES,JIFFS,JIFFY,JILTS,JIMMY,JINGO,JINKS,JIVED,JIVER,JIVES,JIZAN,JOCKS,JOINS,JOINT,JOIST,JOKED,JOKER,JOKES,JOKEY,JOLLY,JOLTS,JOULE,JOUST,JOYED,JUDGE,JUICE,JUICY,JULEP,JUMBO,JUMPS,JUMPY,JUNCO,JUNKS,JUNKY,JUROR,JUSTS,KAFIR,KALES,KAPOK,KAPPA,KAPUT,KARAT,KARMA,KAYAK,KAZOO,KEBAB,KEELS,KEEPS,KELPS,KELPY,KENAF,KENDO,KETCH,KEYED,KHAKI,KICKS,KICKY,KIDDO,KILLS,KILNS,KILTS,KILTY,KINDA,KINDS,KINES,KINGS,KINKS,KINKY,KIOSK,KIRKS,KITED,KITER,KITES,KITHE,KITHS,KITTY,KIWIS,KLICK,KLUTZ,KNACK,KNEAD,KNEED,KNEEL,KNEES,KNELL,KNELT,KNIFE,KNITS,KNOBS,KNOCK,KNOLL,KNOTS,KNOWN,KNOWS,KNURL,KOALA,KOOKS,KOOKY,KRAUT,KRILL,KUDOS,KUDZU,LABEL,LABOR,LACED,LACER,LACES,LACEY,LACKS,LADED,LADEN,LADES,LADLE,LAGER,LAIRD,LAIRS,LAKED,LAKES,LAMAS,LAMBS,LAMED,LAMER,LAMES,LAMPS,LANCE,LANDS,LANES,LANKY,LAPEL,LAPSE,LARGE,LARKS,LARKY,LARVA,LASED,LASER,LASES,LASSO,LASTS,LATCH,LATER,LATEX,LATHE,LATHS,LATTE,LAUDS,LAUGH,LAVAS,LAWNS,LAYER,LAYUP,LAZED,LAZES,LEACH,LEADS,LEADY,LEAFS,LEAFY,LEAKS,LEAKY,LEANS,LEANT,LEAPS,LEAPT,LEARN,LEASE,LEASH,LEAST,LEAVE,LEDGE,LEDGY,LEECH,LEEKS,LEERS,LEERY,LEFTS,LEFTY,LEGAL,LEMMA,LEMME,LEMON,LEMUR,LENDS,LEPER,LESBO,LETUP,LEVEE,LEVEL,LEVER,LIANA,LIARS,LIBEL,LICKS,LIDOS,LIEGE,LIENS,LIFER,LIFTS,LIGHT,LIKED,LIKEN,LIKER,LIKES,LILAC,LILTS,LIMBO,LIMBS,LIMBY,LIMED,LIMES,LIMEY,LIMIT,LIMNS,LIMOS,LIMPS,LINED,LINEN,LINER,LINES,LINGO,LINGS,LINKS,LINTY,LINUX,LIONS,LIPID,LIPPY,LISLE,LISPS,LISTS,LITER,LITHE,LITRE,LIVED,LIVEN,LIVER,LIVES,LIVID,LLAMA,LLANO,LOACH,LOADS,LOAFS,LOAMY,LOANS,LOATH,LOBBY,LOBED,LOBES,LOCAL,LOCUS,LODGE,LOFTS,LOFTY,LOGIC,LOGIN,LOINS,LOLLS,LONER,LONGS,LOOFA,LOOKS,LOOMS,LOONS,LOONY,LOOPS,LOOPY,LOOSE,LOOTS,LOPED,LOPER,LOPES,LORDS,LORDY,LORES,LOSER,LOSES,LOSSY,LOTTO,LOTUS,LOUSE,LOUSY,LOUTS,LOVED,LOVER,LOVES,LOWED,LOWER,LOWLY,LOYAL,LUBED,LUBES,LUCID,LUCKS,LUCKY,LUCRE,LUDES,LUDIC,LUFFA,LULLS,LUMEN,LUMPS,LUMPY,LUNAR,LUNCH,LUNGE,LUNGS,LUPIN,LUPUS,LURCH,LURED,LURER,LURES,LURKS,LUSTS,LUSTY,LUSUS,LUTES,LYING,LYMPH,LYNCH,LYRIC,MACHO,MACRO,MADAM,MADLY,MAFIA,MAGIC,MAGMA,MAIDS,MAILS,MAIMS,MAINS,MAIZE,MAJOR,MAKER,MAKES,MALES,MAMBO,MAMMA,MAMMY,MANGA,MANGE,MANGO,MANGY,MANIA,MANIC,MANLY,MANOR,MAPLE,MARCH,MARES,MARKS,MARRY,MARSH,MASKS,MASON,MASSE,MASTS,MATCH,MATED,MATER,MATES,MATEY,MATHS,MATTE,MAULS,MAVEN,MAXED,MAXES,MAXIM,MAYOR,MAZES,MEADS,MEALS,MEALY,MEANS,MEANT,MEANY,MEATS,MEATY,MECCA,MEDAL,MEDIA,MEDIC,MEETS,MELDS,MELEE,MELON,MELTS,MEMOS,MENDS,MENUS,MEOWS,MERCY,MERGE,MERIT,MERRY,MESHY,MESSY,METAL,METED,METER,METHS,METRO,MICRO,MIDST,MIGHT,MIKED,MIKES,MILCH,MILDS,MILER,MILES,MILKS,MILKY,MILLS,MIMED,MIMER,MIMES,MIMIC,MINCE,MINCY,MINDS,MINED,MINER,MINES,MINIM,MINKS,MINOR,MINTS,MINTY,MINUS,MIRED,MIRES,MIRTH,MISER,MISSY,MISTS,MISTY,MITER,MITRE,MITTS,MIXED,MIXER,MIXES,MOANS,MOATS,MOCHA,MOCKS,MODAL,MODEL,MODEM,MODES,MODUS,MOGUL,MOIST,MOLAR,MOLDS,MOLDY,MOLES,MOLLS,MOLLY,MOLTO,MOLTS,MOMMA,MOMMY,MONKS,MONTH,MOODS,MOODY,MOOED,MOONS,MOONY,MOORS,MOOSE,MOOTS,MOPED,MOPER,MOPES,MOPEY,MORAL,MOREL,MORES,MORNS,MORON,MORPH,MORSE,MOSSY,MOTEL,MOTES,MOTHS,MOTHY,MOTIF,MOTOR,MOTTO,MOULT,MOUND,MOUNT,MOURN,MOUSE,MOUSY,MOUTH,MOVED,MOVER,MOVES,MOVIE,MOWED,MOWER,MOXIE,MUCIN,MUCKS,MUCKY,MUCUS,MUDDY,MUFFS,MUFTI,MULED,MULES,MULLS,MUMPS,MUNCH,MUNGS,MUONS,MURAL,MURKS,MURKY,MUSED,MUSER,MUSES,MUSHY,MUSIC,MUSKS,MUSKY,MUSTS,MUSTY,MUTED,MUTER,MUTES,MUTTS,MUZZY,MYNAH,MYNAS,MYRRH,MYTHS,NACHO,NADIR,NAILS,NAIVE,NAKED,NAMED,NAMER,NAMES,NANNY,NAPES,NAPPY,NARCO,NARCS,NARKS,NARKY,NASAL,NASTY,NATAL,NATES,NATTY,NAVAL,NAVEL,NAVES,NAVVY,NAZIS,NEAPS,NEARS,NEATH,NECKS,NEEDS,NEEDY,NEGRO,NEIGH,NEONS,NERDS,NERDY,NERVE,NERVY,NESTS,NEVER,NEWER,NEWLY,NEWSY,NEWTS,NEXUS,NICER,NICHE,NICKS,NIECE,NIFTY,NIGHT,NIMBY,NINJA,NINNY,NINTH,NIPPY,NITER,NITRE,NITRO,NITTY,NIXED,NIXES,NIXIE,NOBLE,NOBLY,NODAL,NODDY,NODES,NOHOW,NOISE,NOISY,NOMAD,NONCE,NONES,NONNY,NOOKS,NOOKY,NOONS,NOOSE,NORMS,NORTH,NOSED,NOSER,NOSES,NOSEY,NOTCH,NOTED,NOTER,NOTES,NOUNS,NOVAE,NOVAS,NOVEL,NUBBY,NUKED,NUKES,NULLS,NUMBS,NURSE,NUTSY,NUTTY,NYLON,NYMPH,OAKEN,OAKUM,OARED,OASES,OASIS,OATER,OATHS,OBEAH,OBESE,OBEYS,OCCUR,OCEAN,OCHER,OCHRE,OCTAL,OCTET,OCTYL,OCULI,ODDER,ODDLY,ODEUM,ODORS,ODOUR,OFFAL,OFFED,OFFER,OFTEN,OGLED,OGLER,OGLES,OGRES,OHHHH,OHING,OILED,OILER,OINKS,OKAPI,OKAYS,OKRAS,OLDEN,OLDER,OLDIE,OLIVE,OMBRE,OMEGA,OMENS,OMITS,ONION,ONSET,OOHED,OOZED,OOZES,OPALS,OPENS,OPERA,OPINE,OPIUM,OPTED,OPTIC,ORALS,ORATE,ORBIT,ORCAS,ORDER,ORGAN,ORIBI,OSIER,OTHER,OTTER,OUGHT,OUNCE,OUSEL,OUSTS,OUTDO,OUTED,OUTER,OUTGO,OUTRE,OVARY,OVATE,OVENS,OVERT,OVOID,OVULE,OWING,OWLED,OWLER,OWNED,OWNER,OXBOW,OXIDE,OXTER,OZONE,PACED,PACER,PACES,PACKS,PACTS,PADDY,PADRE,PAEAN,PAGAN,PAGED,PAGER,PAGES,PAILS,PAINS,PAINT,PAIRS,PALER,PALES,PALLS,PALMS,PALMY,PALSY,PANDA,PANED,PANEL,PANES,PANGS,PANIC,PANSY,PANTS,PANTY,PAPAL,PAPAS,PAPAW,PAPER,PAPPY,PARAM,PARCH,PARDS,PARED,PARER,PARES,PARIS,PARKA,PARKS,PARKY,PARRY,PARSE,PARTS,PARTY,PASED,PASES,PASSE,PASTE,PASTS,PASTY,PATCH,PATER,PATHS,PATIO,PATSY,PATTY,PAUSE,PAVED,PAVER,PAVES,PAWED,PAWER,PAWLS,PAWNS,PAYED,PAYEE,PAYER,PEACE,PEACH,PEAKS,PEAKY,PEALS,PEARL,PEARS,PEATS,PEATY,PECAN,PECKS,PEDAL,PEEKS,PEELS,PEENS,PEEPS,PEERS,PEEVE,PENAL,PENCE,PENDS,PENIS,PENNY,PEONS,PEPPY,PERCH,PERDU,PERKS,PERKY,PERMS,PERRY,PESKY,PESOS,PESTS,PESTY,PETAL,PETER,PETIT,PETRI,PETTY,PEWEE,PEWIT,PHASE,PHONE,PHONY,PHOTO,PIANO,PICKY,PIECE,PIERS,PIETA,PIETY,PIGGY,PIKED,PIKER,PIKES,PILED,PILES,PILLS,PILOT,PIMPS,PINCH,PINED,PINES,PINGS,PINKO,PINKS,PINKY,PINNA,PINNY,PINOT,PINTO,PINTS,PINUP,PIONS,PIOUS,PIPED,PIPER,PIPES,PIQUE,PITCH,PITHS,PITHY,PITON,PITTA,PIVOT,PIXEL,PIXIE,PIZZA,PLACE,PLAID,PLAIN,PLAIT,PLANE,PLANK,PLANS,PLANT,PLASH,PLASM,PLATE,PLATS,PLAYA,PLAYS,PLAZA,PLEAD,PLEAS,PLEAT,PLEBE,PLEBS,PLENA,PLIED,PLIER,PLIES,PLINK,PLODS,PLONK,PLOPS,PLOTS,PLOWS,PLOYS,PLUCK,PLUGS,PLUMB,PLUME,PLUMP,PLUMS,PLUMY,PLUNK,PLUSH,PLYER,POACH,POCKS,POCKY,PODGY,PODIA,POEMS,POETS,POINT,POISE,POKED,POKER,POKES,POKEY,POLAR,POLED,POLER,POLES,POLIO,POLIS,POLKA,POLLS,POLYP,POLYS,POMPS,PONCE,PONCY,PONDS,PONGS,PONGY,POOCH,POOEY,POOFS,POOFY,POOHS,POOLS,POOPS,POOPY,POPES,POPPA,POPPY,PORCH,PORED,PORER,PORES,PORGY,PORKS,PORKY,PORNO,PORNS,PORTS,POSED,POSER,POSES,POSIT,POSSE,POSTS,POTTY,POUCH,POUFS,POUND,POURS,POUTS,POUTY,POWER,POXES,PRAMS,PRANG,PRANK,PRAPS,PRATE,PRAWN,PRAYS,PREEN,PRESA,PRESS,PREYS,PRICE,PRICY,PRIDE,PRIED,PRIER,PRIES,PRIMA,PRIME,PRIMP,PRIMS,PRINT,PRION,PRIOR,PRISM,PRISS,PRIVY,PRIZE,PROAS,PROBE,PROBS,PRODS,PROEM,PROFS,PROMO,PROMS,PRONE,PRONG,PROOF,PROPS,PROSE,PROSY,PROUD,PROVE,PROWL,PROWS,PRUDE,PRUNE,PRYER,PSALM,PSEUD,PSHAW,PSYCH,PUBIC,PUBIS,PUCKS,PUDGE,PUDGY,PUFFS,PUFFY,PUKED,PUKER,PUKES,PULED,PULER,PULES,PULLS,PULPS,PULPY,PULSE,PUMAS,PUMPS,PUNCH,PUNKS,PUNKY,PUNNY,PUNTS,PUPAE,PUPAL,PUPAS,PUPIL,PUPPY,PUREE,PURER,PURGE,PURRS,PURSE,PURSY,PUSHY,PUSSY,PUTON,PUTTS,PUTTY,PYGMY,PYLON,PYRES,PYREX,QUACK,QUADS,QUAFF,QUAGS,QUAIL,QUALM,QUARK,QUART,QUASI,QUAYS,QUEEN,QUEER,QUELL,QUERY,QUEST,QUEUE,QUICK,QUIDS,QUIET,QUIFF,QUILL,QUILT,QUINT,QUIPS,QUIRK,QUIRT,QUITE,QUITS,QUOTA,QUOTE,QUOTH,RABBI,RABID,RACED,RACER,RACES,RACKS,RADAR,RADII,RADIO,RADIX,RADON,RAFFS,RAFTS,RAGED,RAGER,RAGES,RAGGY,RAIDS,RAILS,RAINS,RAINY,RAISE,RAJAH,RAKED,RAKER,RAKES,RALLY,RAMPS,RANCH,RANDO,RANDS,RANDY,RANGE,RANGY,RANKS,RANTS,RAPED,RAPER,RAPES,RAPID,RARER,RASHY,RASPS,RASPY,RATED,RATER,RATES,RATIO,RATTY,RAVED,RAVEL,RAVEN,RAVER,RAVES,RAWER,RAWLY,RAYON,RAZED,RAZES,RAZOR,REACH,REACT,READS,READY,REALM,REALS,REAMS,REAPS,REARS,REBEL,REBID,REBUS,REBUT,RECAP,RECCE,RECKS,RECTO,RECUR,REDID,REDLY,REDOS,REEDS,REEDY,REEFS,REEFY,REEKS,REEKY,REELS,REEVE,REFER,REFIT,REGAL,REHAB,REIGN,REINS,REIST,RELAX,RELAY,RELIC,REMIT,REMIX,RENAL,RENDS,RENEW,RENTS,REPAY,REPEL,REPLY,REPOS,REPOT,REPRO,RERAN,RERUN,RESAT,RESET,RESIN,RESIT,RESTS,RETCH,RETIE,RETRO,RETRY,REUSE,REVEL,REWED,RHEUM,RHINO,RHYME,RHYMY,RIALS,RIATA,RIBBY,RICED,RICER,RICES,RICEY,RIDER,RIDES,RIDGE,RIDGY,RIFFS,RIFLE,RIFTS,RIGHT,RIGID,RIGOR,RILED,RILES,RILEY,RILLS,RINDS,RINDY,RINGS,RINKS,RINSE,RIOJA,RIOTS,RIPED,RIPEN,RIPER,RIPES,RISEN,RISER,RISES,RISHI,RISKS,RISKY,RISUS,RITES,RITZY,RIVAL,RIVED,RIVEN,RIVER,RIVES,RIVET,ROACH,ROADS,ROAMS,ROARS,ROAST,ROBED,ROBES,ROBIN,ROBOT,ROCKS,ROCKY,RODEO,ROGUE,ROILS,ROILY,ROLES,ROLLS,ROMAN,ROMEO,ROMPS,RONDO,ROODS,ROOFS,ROOKS,ROOKY,ROOMS,ROOMY,ROOST,ROOTS,ROOTY,ROPED,ROPER,ROPES,ROSES,ROSIN,ROTOR,ROUGE,ROUGH,ROUND,ROUSE,ROUTE,ROVED,ROVER,ROVES,ROWDY,ROWED,ROWER,ROYAL,RUBES,RUBLE,RUCKS,RUDDY,RUDER,RUFFS,RUGBY,RUING,RUINS,RULED,RULER,RULES,RUMBA,RUMMY,RUMOR,RUMPS,RUNGS,RUNIC,RUNNY,RUNTS,RUNTY,RUPEE,RURAL,RUSSE,RUSTS,RUSTY,RUTTY,SABLE,SABOT,SACKS,SADLY,SAFER,SAFES,SAGAS,SAGER,SAGES,SAHIB,SAIDS,SAILS,SAINT,SAITH,SAKES,SALAD,SALES,SALLY,SALON,SALSA,SALTS,SALTY,SALVE,SALVO,SAMBA,SAMES,SAMEY,SANDY,SANER,SAPPY,SARGE,SARIS,SARKY,SASSY,SATAY,SATED,SATES,SATIN,SATYR,SAUCE,SAUCY,SAUNA,SAUTE,SAVED,SAVER,SAVES,SAVOR,SAVOY,SAVVY,SAWED,SAWER,SAXES,SAYER,SCABS,SCADS,SCALD,SCALE,SCALP,SCALY,SCAMP,SCAMS,SCANS,SCARE,SCARF,SCARP,SCARS,SCARY,SCENE,SCENT,SCHMO,SCHWA,SCION,SCOFF,SCOLD,SCONE,SCOOP,SCOOT,SCOPE,SCOPS,SCORE,SCORN,SCOTS,SCOUR,SCOUT,SCOWL,SCOWS,SCRAM,SCRAP,SCREE,SCREW,SCRIM,SCRIP,SCROD,SCRUB,SCRUM,SCUBA,SCUDS,SCUFF,SCULK,SCULL,SEALS,SEAMS,SEAMY,SEARS,SEATS,SECTS,SEDAN,SEDGE,SEDGY,SEDUM,SEEDS,SEEDY,SEEKS,SEEMS,SEEPS,SEEPY,SEERS,SEGUE,SEIZE,SELLS,SEMEN,SEMIS,SENDS,SENOR,SENSE,SEPAL,SEPIA,SEPOY,SEPTA,SERFS,SERGE,SERIF,SERUM,SERVE,SERVO,SETUP,SEVEN,SEVER,SEWED,SEWER,SEXED,SEXES,SHACK,SHADE,SHADS,SHADY,SHAFT,SHAGS,SHAKE,SHAKO,SHAKY,SHALE,SHALL,SHALT,SHAME,SHAMS,SHANK,SHAPE,SHARD,SHARE,SHARK,SHARP,SHAVE,SHAWL,SHAWM,SHAYS,SHEAF,SHEAR,SHEDS,SHEEN,SHEEP,SHEER,SHEET,SHEIK,SHELF,SHELL,SHEWN,SHEWS,SHIED,SHIER,SHIES,SHIFT,SHILL,SHIMS,SHINE,SHINS,SHINY,SHIPS,SHIRE,SHIRK,SHIRR,SHIRT,SHISH,SHITS,SHIVE,SHOAL,SHOCK,SHOED,SHOER,SHOES,SHOJI,SHONE,SHOOK,SHOOS,SHOOT,SHOPS,SHORE,SHORN,SHORT,SHOTE,SHOTS,SHOUT,SHOVE,SHOWN,SHOWS,SHOWY,SHRED,SHREW,SHRUB,SHRUG,SHUCK,SHUNT,SHUSH,SHUTS,SHYLY,SIBYL,SIDED,SIDER,SIDES,SIDLE,SIEGE,SIEVE,SIFTS,SIGHS,SIGHT,SIGMA,SIGNA,SIGNS,SILKS,SILKY,SILLS,SILLY,SILTS,SILTY,SINCE,SINEW,SINGE,SINGS,SINKS,SINKY,SINUS,SIREN,SIRES,SISSY,SITAR,SITED,SITES,SITUP,SITUS,SIXER,SIXES,SIXTH,SIXTY,SIZED,SIZER,SIZES,SKALD,SKANK,SKATE,SKATS,SKEAN,SKEED,SKEES,SKEET,SKEIN,SKELP,SKENE,SKEPS,SKEWS,SKIDS,SKIED,SKIER,SKIES,SKIEY,SKIFF,SKILL,SKIMP,SKIMS,SKINS,SKINT,SKIPS,SKIRL,SKIRT,SKITS,SKIVE,SKOAL,SKULL,SKUNK,SLABS,SLACK,SLAGS,SLAIN,SLAKE,SLAMS,SLANG,SLANT,SLAPS,SLASH,SLATE,SLATS,SLATY,SLAVE,SLAYS,SLEDS,SLEEK,SLEEP,SLEET,SLEPT,SLICE,SLICK,SLIDE,SLIER,SLILY,SLIME,SLIMS,SLIMY,SLING,SLINK,SLIPS,SLITS,SLOBS,SLOES,SLOGS,SLOMO,SLOPS,SLOSH,SLOTH,SLOTS,SLOWS,SLUBS,SLUED,SLUES,SLUGS,SLUMP,SLUMS,SLUNG,SLUNK,SLURP,SLURS,SLUSH,SLYER,SLYLY,SMACK,SMALL,SMARM,SMART,SMASH,SMEAR,SMELL,SMELT,SMILE,SMIRK,SMITE,SMITH,SMOCK,SMOGS,SMOKE,SMOKY,SMOLT,SMOTE,SNACK,SNAFU,SNAGS,SNAIL,SNAKE,SNAKY,SNAPS,SNARE,SNARF,SNARL,SNEAK,SNEER,SNELL,SNICK,SNIDE,SNIFF,SNIPE,SNIPS,SNITS,SNOBS,SNOGS,SNOOD,SNOOP,SNOOT,SNORE,SNORT,SNOTS,SNOUT,SNOWS,SNOWY,SNUBS,SNUCK,SNUFF,SNUGS,SOAKS,SOAPS,SOAPY,SOARS,SOBER,SOCKO,SOCKS,SOFAS,SOFTA,SOFTS,SOFTY,SOGGY,SOILS,SOLAR,SOLED,SOLES,SOLID,SOLON,SOLOS,SOLVE,SONAR,SONGS,SONIC,SONNY,SOOTH,SOOTS,SOOTY,SOPPY,SORRY,SORTA,SORTS,SOUKS,SOULS,SOUND,SOUPS,SOUPY,SOURS,SOUTH,SOWED,SOWER,SPACE,SPACY,SPADE,SPAKE,SPAMS,SPANG,SPANK,SPANS,SPARE,SPARK,SPARS,SPASM,SPATE,SPAWN,SPAYS,SPEAK,SPEAR,SPECK,SPECS,SPEED,SPELL,SPELT,SPEND,SPENT,SPERM,SPICE,SPICY,SPIED,SPIEL,SPIER,SPIES,SPIFF,SPIKE,SPIKY,SPILL,SPILT,SPINE,SPINS,SPINY,SPIRE,SPITE,SPITS,SPITZ,SPLAT,SPLAY,SPLIT,SPOIL,SPOKE,SPOOF,SPOOK,SPOOL,SPOON,SPOOR,SPORE,SPORT,SPOTS,SPOUT,SPRAT,SPRAY,SPREE,SPRIG,SPRIT,SPRUE,SPUDS,SPUED,SPUES,SPUME,SPUMY,SPUNK,SPURN,SPURR,SPURS,SPURT,SQUAD,SQUAT,SQUAW,SQUIB,SQUID,STACK,STAFF,STAGE,STAGS,STAGY,STAID,STAIN,STAIR,STAKE,STALE,STALK,STALL,STAMP,STAND,STANK,STAPH,STARE,STARK,STARS,START,STASH,STATE,STATS,STAVE,STAYS,STEAD,STEAK,STEAL,STEAM,STEED,STEEL,STEEP,STEER,STEMS,STENO,STEPS,STERN,STETS,STEWS,STICK,STIFF,STILE,STILL,STILT,STING,STINK,STINT,STIRS,STOCK,STOGY,STOIC,STOKE,STOLE,STOMP,STONE,STONY,STOOD,STOOL,STOOP,STOPS,STORE,STORK,STORM,STORY,STOUP,STOUT,STOVE,STOWS,STRAP,STRAW,STRAY,STREP,STREW,STRIP,STROP,STRUT,STUCK,STUDS,STUDY,STUFF,STUMP,STUMS,STUNG,STUNK,STUNS,STUNT,STUPA,STYLE,STYLI,SUAVE,SUCKS,SUCKY,SUDSY,SUEDE,SUETS,SUETY,SUGAR,SUING,SUITE,SUITS,SULKS,SULKY,SULLY,SUMAC,SUMMA,SUMOS,SUMPS,SUNKS,SUNNY,SUNUP,SUPER,SUPRA,SURDS,SURER,SURFS,SURFY,SURGE,SURGY,SURLY,SUSHI,SWABS,SWAGE,SWAGS,SWAIN,SWALE,SWAMI,SWAMP,SWANK,SWANS,SWAPS,SWARD,SWARM,SWART,SWASH,SWATH,SWATS,SWAYS,SWEAR,SWEAT,SWEDE,SWEEP,SWEET,SWELL,SWEPT,SWIFT,SWIGS,SWILL,SWIMS,SWINE,SWING,SWIPE,SWIRL,SWISH,SWISS,SWOON,SWOOP,SWORD,SWORE,SWORN,SWOTS,SWUNG,SYLPH,SYNCH,SYNOD,SYNTH,SYRUP,TABBY,TABLE,TABOO,TABOR,TABUS,TACIT,TACKS,TACKY,TACOS,TACTS,TAELS,TAFFY,TAILS,TAINT,TAKEN,TAKER,TAKES,TALAS,TALES,TALKS,TALKY,TALLS,TALLY,TALON,TAMED,TAMER,TAMES,TAMIS,TAMPS,TANGO,TANGS,TANGY,TANKS,TANSY,TAPAS,TAPED,TAPER,TAPES,TAPIR,TAPIS,TARDY,TARED,TARES,TARNS,TAROS,TAROT,TARPS,TARRY,TARTS,TARTY,TASKS,TASTE,TASTY,TATER,TATTY,TAUNT,TAUPE,TAWNY,TAXED,TAXER,TAXES,TAXIS,TEACH,TEAKS,TEALS,TEAMS,TEARS,TEARY,TEASE,TEATS,TECHS,TECHY,TEDDY,TEEMS,TEENS,TEENY,TEETH,TELLS,TELLY,TEMPO,TEMPS,TEMPT,TENCH,TENDS,TENET,TENOR,TENSE,TENTH,TENTS,TEPEE,TEPID,TERMS,TERNS,TERRA,TERRY,TERSE,TESLA,TESTS,TESTY,TEXTS,THANE,THANK,THAWS,THEFT,THEIR,THEME,THEMS,THERE,THERM,THESE,THETA,THEWS,THICK,THIEF,THIGH,THINE,THING,THINK,THINS,THIRD,THONG,THORN,THOSE,THOUS,THREE,THREW,THROB,THROW,THRUM,THUDS,THUGS,THUMB,THUMP,THUNK,THYME,TIARA,TIBIA,TICKS,TIDAL,TIDED,TIDES,TIERS,TIGER,TIGHT,TIKES,TILDE,TILED,TILER,TILES,TILLS,TILTS,TIMED,TIMER,TIMES,TIMID,TINCT,TINEA,TINED,TINES,TINGE,TINGS,TINNY,TINTS,TIPPY,TIPSY,TIRED,TIRES,TITAN,TITER,TITLE,TITRE,TITTY,TOADS,TOADY,TOAST,TODAY,TODDY,TOFFS,TOFFY,TOFUS,TOGAS,TOGGL,TOGUE,TOILE,TOILS,TOKED,TOKEN,TOKES,TOLLS,TOMBS,TOMES,TONAL,TONDO,TONED,TONER,TONES,TONGS,TONIC,TONNE,TOOLS,TOOTH,TOOTS,TOPAZ,TOPED,TOPEE,TOPER,TOPES,TOPHI,TOPIC,TOPIS,TOPPY,TOQUE,TORAH,TORCH,TORED,TORES,TORIC,TORII,TOROS,TORSE,TORSI,TORSO,TORTE,TORTS,TORUS,TOTAL,TOTED,TOTEM,TOTER,TOTES,TOUCH,TOUGH,TOURS,TOUSE,TOUTS,TOWED,TOWEL,TOWER,TOWNS,TOWNY,TOXIC,TOXIN,TOYED,TOYER,TRACE,TRACK,TRACT,TRADE,TRAIL,TRAIN,TRAIT,TRAMP,TRAMS,TRANS,TRAPS,TRASH,TRAWL,TRAYS,TREAD,TREAT,TREED,TREES,TREKS,TREND,TRESS,TREWS,TRIAD,TRIAL,TRIBE,TRICE,TRICK,TRIED,TRIER,TRIES,TRIGO,TRIGS,TRIKE,TRILL,TRIMS,TRINE,TRIOS,TRIPE,TRIPS,TRITE,TROAD,TROLL,TROMP,TROOP,TROTH,TROTS,TROUT,TROVE,TROWS,TRUCE,TRUCK,TRUED,TRUER,TRUES,TRULY,TRUMP,TRUNK,TRUSS,TRUST,TRUTH,TRYPS,TRYST,TSUBA,TUBAS,TUBBY,TUBED,TUBER,TUBES,TUCKS,TUFFS,TUFTS,TUFTY,TULIP,TULLE,TUMID,TUMMY,TUMOR,TUMPS,TUNAS,TUNED,TUNER,TUNES,TUNIC,TUNNY,TUPLE,TURBO,TURDS,TURFS,TURFY,TURNS,TURPS,TUSCH,TUSKS,TUSKY,TUTOR,TUTTI,TUTUS,TUXES,TWAIN,TWANG,TWEAK,TWEED,TWEET,TWERP,TWICE,TWIGS,TWILL,TWINE,TWINK,TWINS,TWINY,TWIRL,TWIRP,TWIST,TWITS,TWIXT,TYPED,TYPER,TYPES,TYPOS,TYRED,TYRES,TYROS,UDDER,UGHED,UKASE,UKELP,UKING,ULCER,ULNAS,ULTRA,UMBEL,UMBER,UMBRA,UMIAK,UMPED,UMPTY,UNAPT,UNARC,UNARM,UNARY,UNAUS,UNBID,UNBOX,UNCAP,UNCIA,UNCLE,UNCOS,UNCOY,UNCRY,UNCUT,UNDAE,UNDEE,UNDER,UNDID,UNDIM,UNDUE,UNFIT,UNFUN,UNGOT,UNHIP,UNIFY,UNION,UNITE,UNITS,UNITY,UNJAM,UNKED,UNKET,UNKEY,UNKID,UNLAY,UNLED,UNLET,UNLIT,UNMAN,UNMAP,UNMET,UNMEW,UNMIX,UNODE,UNOIL,UNPEG,UNPEN,UNPIN,UNRED,UNREF,UNRIG,UNRIP,UNSAY,UNSET,UNSEW,UNSEX,UNSOD,UNTAP,UNTAX,UNTIE,UNTIL,UNWED,UNWET,UNWIT,UNWON,UNZIP,UPBOW,UPPED,UPPER,UPSET,URBAN,UREAL,UREAS,URGED,URGER,URGES,URIAL,URINE,URNED,USAGE,USERS,USHER,USING,USUAL,USURP,USURY,UTERI,UTILE,UTTER,UVEAL,UVEAS,UVULA,VAGUE,VAGUS,VAILS,VAINS,VALES,VALET,VALID,VALOR,VALUE,VALVE,VAMPS,VAMPY,VANDA,VANED,VANES,VANGS,VAPID,VAPOR,VARAS,VARIA,VARNA,VASAL,VASES,VASTS,VASTY,VATIC,VATOS,VAULT,VAUNT,VEALS,VEALY,VEENA,VEEPS,VEERS,VEERY,VEGAN,VEGAS,VEGES,VEGIE,VEILS,VEILY,VEINS,VEINY,VELAR,VELDS,VELDT,VELUM,VENAL,VENDS,VENOM,VENTS,VENUE,VENUS,VERBS,VERGE,VERSE,VERSO,VERST,VERTS,VERTU,VERVE,VESTA,VESTS,VETCH,VEXED,VEXER,VEXES,VIAND,VIBES,VICAR,VIDEO,VIERS,VIEWS,VIEWY,VIGAS,VIGOR,VILER,VILLA,VILLS,VIMEN,VINAL,VINAS,VINCA,VINED,VINES,VINIC,VINOS,VINYL,VIOLA,VIOLS,VIPER,VIRAL,VIREO,VIRES,VIRGA,VIRID,VIRTU,VIRUS,VISAS,VISED,VISES,VISIT,VISOR,VISTA,VITAE,VITAL,VITRO,VITTY,VIVAS,VIVAT,VIVER,VIVES,VIVID,VIXEN,VIZOR,VOCAB,VOCAL,VODKA,VOGUE,VOICE,VOIDS,VOILA,VOILE,VOLAR,VOLED,VOLES,VOLKS,VOLTA,VOLTS,VOLVA,VOMER,VOMIT,VOTED,VOTER,VOTES,VOUCH,VOWED,VOWEL,VOWER,VROOM,VUGGS,VUGGY,VUGHS,VULGO,VULNS,VULVA,VYING,WACKO,WACKY,WADDY,WADED,WADER,WADES,WADIS,WAFER,WAFTS,WAGED,WAGER,WAGES,WAGON,WAHOO,WAIFS,WAILS,WAIST,WAITS,WAIVE,WAKED,WAKEN,WAKER,WAKES,WALKS,WALLA,WALLS,WALLY,WALTZ,WANDS,WANED,WANES,WANGS,WANKS,WANLY,WANTS,WARDS,WARED,WARES,WARMS,WARNS,WARPS,WARTS,WARTY,WASES,WASHY,WASPS,WASPY,WASTE,WATCH,WATER,WATTS,WAUKS,WAULS,WAVED,WAVER,WAVES,WAVEY,WAXED,WAXEN,WAXER,WAXES,WAZOO,WEALD,WEALS,WEANS,WEARS,WEARY,WEAVE,WEBBY,WEBER,WEDGE,WEDGY,WEEDS,WEEDY,WEEKS,WEENS,WEENY,WEEPS,WEEPY,WEETS,WEFTS,WEIGH,WEIRD,WEIRS,WELSH,WELTS,WENCH,WENDS,WENNY,WESTS,WETLY,WHACK,WHALE,WHAMO,WHAMS,WHANG,WHAPS,WHARF,WHATS,WHAUP,WHEAL,WHEAT,WHEEL,WHELK,WHELM,WHELP,WHENS,WHERE,WHETS,WHEWS,WHEYS,WHICH,WHIDS,WHIFF,WHILE,WHIMS,WHINE,WHINS,WHINY,WHIPS,WHIPT,WHIRL,WHIRR,WHIRS,WHISK,WHIST,WHITE,WHITS,WHITY,WHIZZ,WHOLE,WHOMP,WHOOP,WHOPS,WHORE,WHORL,WHOSE,WHOSO,WHUMP,WICKS,WIDEN,WIDER,WIDES,WIDOW,WIDTH,WIELD,WIFED,WIFES,WIFEY,WIFTY,WIGAN,WIGGY,WIGHT,WILDS,WILED,WILES,WILLS,WILLY,WILTS,WIMPS,WIMPY,WINCE,WINCH,WINDS,WINDY,WINED,WINES,WINEY,WINGS,WINGY,WINKS,WINOS,WIPED,WIPER,WIPES,WIRED,WIRER,WIRES,WISED,WISER,WISES,WISPS,WISPY,WITCH,WITHE,WITHS,WITHY,WITTY,WIVED,WIVER,WIVES,WIZEN,WIZES,WOADS,WOALD,WODGE,WOKEN,WOLDS,WOLFS,WOMAN,WOMBS,WOMBY,WOMEN,WONKS,WONKY,WONTS,WOODS,WOODY,WOOED,WOOER,WOOFS,WOOFY,WOOLY,WOOPS,WOOSH,WOOZY,WORDS,WORDY,WORKS,WORLD,WORMS,WORMY,WORRY,WORSE,WORST,WORTH,WORTS,WOULD,WOUND,WOVEN,WOWED,WRACK,WRANG,WRAPS,WRAPT,WRATH,WREAK,WRECK,WREST,WRIER,WRIES,WRING,WRIST,WRITE,WRITS,WRONG,WROTE,WROTH,WRUNG,WURST,WUSSY,XEBEC,XENIA,XENIC,XENON,XERIC,XEROX,XERUS,XIANS,XYSTS,YACHT,YACKS,YAHOO,YALES,YAMPS,YANGS,YANKS,YAPOK,YAUDS,YAULD,YAUPS,YAWED,YAWLS,YAWNS,YAWNY,YAWPS,YEAHS,YEARN,YEARS,YEAST,YEGGS,YELKS,YELLS,YELPS,YENTA,YENTE,YERBA,YERKS,YESES,YETIS,YETTS,YEUCH,YEUKS,YEUKY,YIELD,YIKES,YILLS,YINCE,YIPES,YIRDS,YIRRS,YIRTH,YOBBO,YOCKS,YODEL,YODHS,YODLE,YOGAS,YOGEE,YOGHS,YOGIC,YOGIN,YOGIS,YOKED,YOKEL,YOKER,YOKES,YOLKS,YOLKY,YOMIM,YONIC,YONIS,YOOPS,YORES,YOUNG,YOURN,YOURS,YOUSE,YOUTH,YOWED,YOWES,YOWIE,YOWLS,YUANS,YUCAS,YUCCA,YUCCH,YUCKS,YUCKY,YUGAS,YUKKS,YUKKY,YULES,YUMMY,YUPON,YUPPY,YURTS,ZAIRE,ZAMBO,ZAPPY,ZAZEN,ZEALS,ZEBRA,ZEBUS,ZEINS,ZERKS,ZEROS,ZESTS,ZESTY,ZETAS,ZILCH,ZINCS,ZINCY,ZINEB,ZINES,ZINGS,ZINGY,ZINKY,ZIPPY,ZITIS,ZLOTY,ZOEAE,ZOEAL,ZOEAS,ZOMBI,ZONAL,ZONED,ZONER,ZONES,ZONKS,ZOOEY,ZOOID,ZOOKS,ZOOMS,ZOOMY,ZOPPA,ZOPPO,ZORIS,ZOUKS,ZOWEE,ZOWIE,ZUZIM,ZYMES".split(','));

        // Letter values for scoring
        const LETTER_VALUES = {
            'A': 1, 'B': 3, 'C': 3, 'D': 2, 'E': 1, 'F': 4, 'G': 2, 'H': 4, 'I': 1,
            'J': 8, 'K': 5, 'L': 1, 'M': 3, 'N': 1, 'O': 1, 'P': 3, 'Q': 10, 'R': 1,
            'S': 1, 'T': 1, 'U': 1, 'V': 4, 'W': 4, 'X': 8, 'Y': 4, 'Z': 10
        };

        // Generate random 5-letter game code (24^5 = 7.9 million combinations)
        // Removed I and O to avoid confusion with 1 and 0
        function generateGameCode() {
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            let code = '';
            for (let i = 0; i < 5; i++) {
                code += letters[Math.floor(Math.random() * letters.length)];
            }
            return code;
        }

        // ============ SHARE FUNCTIONS ============
        
        function copyGameCode() {
            const code = gameState.gameCode;
            if (!code) return;
            
            navigator.clipboard.writeText(code).then(() => {
                // Show feedback
                const feedback = document.getElementById('copy-feedback');
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 1500);
            }).catch(err => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = code;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                const feedback = document.getElementById('copy-feedback');
                feedback.classList.add('show');
                setTimeout(() => feedback.classList.remove('show'), 1500);
            });
        }
        
        async function shareGameCode() {
            const code = gameState.gameCode;
            if (!code) return;
            
            const shareData = {
                title: 'ðŸ¥Š Word Boxing Challenge!',
                text: `Join my Word Boxing game! Enter code: ${code}`,
                url: window.location.href
            };
            
            // Check if Web Share API is available
            if (navigator.share && navigator.canShare && navigator.canShare(shareData)) {
                try {
                    await navigator.share(shareData);
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        // User cancelled, do nothing
                        console.log('Share cancelled');
                    }
                }
            } else {
                // Fallback: copy to clipboard and show message
                copyGameCode();
                showMessage('Code copied! Paste it in a message to share.', 'info');
            }
        }
        
        // Check if share is supported and hide button if not on mobile
        function updateShareButtonVisibility() {
            const shareBtn = document.getElementById('share-btn');
            if (shareBtn) {
                // Show share button on mobile or if Web Share API is available
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                const hasShareAPI = navigator.share !== undefined;
                shareBtn.style.display = (isMobile || hasShareAPI) ? 'flex' : 'none';
            }
        }

        // Show/hide phases
        function showPhase(phaseId) {
            // Clean up lobby listener if leaving find-game phase
            const currentPhase = document.querySelector('.phase.active');
            if (currentPhase && currentPhase.id === 'phase-find-game' && phaseId !== 'phase-find-game') {
                cleanupLobbyListener();
            }
            
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active'));
            document.getElementById(phaseId).classList.add('active');
            
            // Update share button visibility when showing create-waiting phase
            if (phaseId === 'phase-create-waiting') {
                updateShareButtonVisibility();
            }
        }

        // Show message toast
        function showMessage(text, type = 'info', duration = 3000) {
            const toast = document.getElementById('message-toast');
            toast.textContent = text;
            toast.className = `message-toast ${type} show`;
            setTimeout(() => toast.classList.remove('show'), duration);
        }

        // Centralized error handler
        function handleError(error, context = 'Operation') {
            console.error(`${context} error:`, error);

            // Determine user-friendly message
            let userMessage = `${context} failed`;

            if (error.code) {
                switch(error.code) {
                    case 'PERMISSION_DENIED':
                        userMessage = 'Permission denied. Please sign in again.';
                        break;
                    case 'NETWORK_ERROR':
                    case 'UNAVAILABLE':
                        userMessage = 'Network error. Please check your connection.';
                        updateConnectionStatus('disconnected');
                        break;
                    case 'auth/popup-closed-by-user':
                        userMessage = 'Sign-in cancelled';
                        break;
                    case 'auth/network-request-failed':
                        userMessage = 'Network error during sign-in';
                        break;
                    default:
                        userMessage = error.message || `${context} failed`;
                }
            } else if (error.message) {
                userMessage = error.message;
            }

            showMessage(userMessage, 'error');
            return userMessage;
        }

        // ==========================================
        // TUTORIAL MANAGER (v0.9.9)
        // Interactive onboarding for new players
        // ==========================================
        // Attach to window for onclick handlers
        window.TutorialManager = {
            steps: [
                {
                    target: null,
                    title: 'Welcome to Word Boxing! ðŸ¥Š',
                    description: 'A competitive 1v1 word puzzle game where you try to guess your opponent\'s secret word before they guess yours.',
                    position: 'center'
                },
                {
                    target: '.lobby-btn.create',
                    title: 'Create Online Game',
                    description: 'Create a private game and share the code with a friend to play online.',
                    position: 'bottom'
                },
                {
                    target: '.lobby-btn.join',
                    title: 'Join a Game',
                    description: 'Enter a game code to join a friend\'s game.',
                    position: 'bottom'
                },
                {
                    target: '.lobby-btn.local',
                    title: 'Pass & Play Mode',
                    description: 'Play with a friend on the same device. Take turns choosing words and guessing!',
                    position: 'bottom'
                },
                {
                    target: '.user-bar',
                    title: 'Sign In to Track Progress',
                    description: 'Sign in with Google to save your stats, earn ELO rating, and appear on the leaderboard!',
                    position: 'bottom'
                },
                {
                    target: null,
                    title: 'How to Play',
                    description: '1. Each player picks a secret 5-letter word\n2. Lower-scoring word goes first\n3. Guess letters or try to solve the whole word\n4. First to solve wins the round!\n5. Best of 3 rounds wins the match',
                    position: 'center'
                },
                {
                    target: null,
                    title: 'Matched Letters',
                    description: 'When the battle begins, letters that appear in BOTH words are automatically revealed in gold. Choose your words strategically!',
                    position: 'center'
                },
                {
                    target: '.menu-btn',
                    title: 'Settings & Help',
                    description: 'Access settings, sound controls, themes, and see the rules anytime from the menu.',
                    position: 'left'
                }
            ],
            currentStep: 0,
            isActive: false,

            init() {
                // Check if user has seen tutorial
                const hasSeenTutorial = localStorage.getItem('wordboxing_tutorial_complete');
                if (!hasSeenTutorial) {
                    // Show tutorial prompt for first-time players
                    setTimeout(() => this.promptStart(), 1500);
                }
            },

            promptStart() {
                if (this.isActive) return;
                // Show custom styled modal instead of native confirm()
                document.getElementById('tutorial-prompt-overlay').classList.add('active');
            },

            acceptPrompt() {
                document.getElementById('tutorial-prompt-overlay').classList.remove('active');
                this.start();
            },

            dismissPrompt() {
                document.getElementById('tutorial-prompt-overlay').classList.remove('active');
                localStorage.setItem('wordboxing_tutorial_complete', 'true');
            },

            start() {
                this.currentStep = 0;
                this.isActive = true;
                document.getElementById('tutorial-overlay').classList.add('active');
                this.buildProgressDots();
                this.showStep(0);
                if (window.SoundManager?.buttonClick) SoundManager.buttonClick();
            },

            buildProgressDots() {
                const progress = document.getElementById('tutorial-progress');
                progress.innerHTML = this.steps.map((_, i) =>
                    `<div class="progress-dot ${i === 0 ? 'active' : ''}" data-step="${i}"></div>`
                ).join('');
            },

            showStep(index) {
                const step = this.steps[index];
                const overlay = document.getElementById('tutorial-overlay');
                const highlight = document.getElementById('tutorial-highlight');
                const tooltip = document.getElementById('tutorial-tooltip');
                const title = document.getElementById('tutorial-title');
                const description = document.getElementById('tutorial-description');
                const indicator = document.getElementById('tutorial-step-indicator');
                const nextBtn = tooltip.querySelector('.tutorial-next');

                // Update content - set text and force styles via setAttribute
                console.log('Setting tutorial step colors...', step.description);

                // Step indicator
                indicator.textContent = `Step ${index + 1} of ${this.steps.length}`;
                indicator.setAttribute('style', 'color: #cccccc !important; -webkit-text-fill-color: #cccccc !important;');

                // Title
                title.textContent = step.title;
                title.setAttribute('style', 'color: #ffd700 !important; -webkit-text-fill-color: #ffd700 !important;');

                // Description
                description.textContent = step.description;

                // Update button text for last step
                nextBtn.textContent = index === this.steps.length - 1 ? 'Start Playing! ðŸ¥Š' : 'Next â†’';

                // Update progress dots
                document.querySelectorAll('.progress-dot').forEach((dot, i) => {
                    dot.classList.toggle('active', i <= index);
                });

                // Reset previous highlighted element
                if (this.currentHighlightedEl) {
                    // Only reset position if we changed it (wasn't fixed/absolute)
                    if (this.originalPosition !== 'fixed' && this.originalPosition !== 'absolute') {
                        this.currentHighlightedEl.style.position = '';
                    }
                    this.currentHighlightedEl.style.zIndex = '';
                    this.currentHighlightedEl.style.pointerEvents = '';
                    this.currentHighlightedEl = null;
                    this.originalPosition = null;
                }

                // Position highlight and tooltip
                if (step.target) {
                    const targetEl = document.querySelector(step.target);
                    if (targetEl) {
                        const rect = targetEl.getBoundingClientRect();
                        highlight.style.display = 'block';
                        highlight.style.top = (rect.top - 8) + 'px';
                        highlight.style.left = (rect.left - 8) + 'px';
                        highlight.style.width = (rect.width + 16) + 'px';
                        highlight.style.height = (rect.height + 16) + 'px';

                        // IMPORTANT: Bring target element above the overlay so it's visible
                        // Only set position if element doesn't already have fixed/absolute positioning
                        const computedPosition = window.getComputedStyle(targetEl).position;
                        if (computedPosition !== 'fixed' && computedPosition !== 'absolute') {
                            targetEl.style.position = 'relative';
                        }
                        targetEl.style.zIndex = '2005';
                        targetEl.style.pointerEvents = 'none'; // Prevent clicks during tutorial
                        this.currentHighlightedEl = targetEl;
                        this.originalPosition = computedPosition;

                        // Position tooltip based on step position
                        this.positionTooltip(tooltip, rect, step.position);
                    } else {
                        highlight.style.display = 'none';
                        this.centerTooltip(tooltip);
                    }
                } else {
                    highlight.style.display = 'none';
                    this.centerTooltip(tooltip);
                }
            },

            positionTooltip(tooltip, targetRect, position) {
                tooltip.style.position = 'fixed';
                const tooltipRect = tooltip.getBoundingClientRect();

                switch(position) {
                    case 'bottom':
                        tooltip.style.top = (targetRect.bottom + 20) + 'px';
                        tooltip.style.left = Math.max(10, Math.min(
                            targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2),
                            window.innerWidth - tooltipRect.width - 10
                        )) + 'px';
                        tooltip.style.transform = 'none';
                        break;
                    case 'left':
                        tooltip.style.top = targetRect.top + 'px';
                        tooltip.style.left = Math.max(10, targetRect.left - tooltipRect.width - 20) + 'px';
                        tooltip.style.transform = 'none';
                        break;
                    case 'right':
                        tooltip.style.top = targetRect.top + 'px';
                        tooltip.style.left = (targetRect.right + 20) + 'px';
                        tooltip.style.transform = 'none';
                        break;
                    default:
                        this.centerTooltip(tooltip);
                }
            },

            centerTooltip(tooltip) {
                tooltip.style.position = 'fixed';
                tooltip.style.top = '50%';
                tooltip.style.left = '50%';
                tooltip.style.transform = 'translate(-50%, -50%)';
            },

            next() {
                if (window.SoundManager?.buttonClick) SoundManager.buttonClick();
                this.currentStep++;
                if (this.currentStep >= this.steps.length) {
                    this.complete();
                } else {
                    this.showStep(this.currentStep);
                }
            },

            skip() {
                if (window.SoundManager?.buttonClick) SoundManager.buttonClick();
                this.complete();
            },

            complete() {
                this.isActive = false;
                // Reset any highlighted element
                if (this.currentHighlightedEl) {
                    // Only reset position if we changed it
                    if (this.originalPosition !== 'fixed' && this.originalPosition !== 'absolute') {
                        this.currentHighlightedEl.style.position = '';
                    }
                    this.currentHighlightedEl.style.zIndex = '';
                    this.currentHighlightedEl.style.pointerEvents = '';
                    this.currentHighlightedEl = null;
                    this.originalPosition = null;
                }
                document.getElementById('tutorial-overlay').classList.remove('active');
                localStorage.setItem('wordboxing_tutorial_complete', 'true');
                showMessage('Tutorial complete! Have fun playing!', 'success');
            },

            // Allow restarting tutorial from settings
            restart() {
                localStorage.removeItem('wordboxing_tutorial_complete');
                this.start();
            }
        };

        // ==========================================
        // LOADING MANAGER (v0.9.10)
        // Centralized loading state management
        // ==========================================
        // Attach to window for potential onclick handlers
        window.LoadingManager = {
            activeLoaders: new Set(),

            // Show full-screen loading overlay
            show(message = 'Loading...') {
                const overlay = document.getElementById('loading-overlay');
                const text = document.getElementById('loading-text');
                if (overlay && text) {
                    text.textContent = message;
                    overlay.classList.add('active');
                }
                this.activeLoaders.add(message);
            },

            // Hide loading overlay
            hide(message = 'Loading...') {
                this.activeLoaders.delete(message);
                // Only hide if no other loaders are active
                if (this.activeLoaders.size === 0) {
                    const overlay = document.getElementById('loading-overlay');
                    if (overlay) {
                        overlay.classList.remove('active');
                    }
                }
            },

            // Set button to loading state
            setButtonLoading(button, loading = true) {
                if (!button) return;
                if (loading) {
                    button.classList.add('loading');
                    button.disabled = true;
                    button.dataset.originalText = button.textContent;
                } else {
                    button.classList.remove('loading');
                    button.disabled = false;
                    if (button.dataset.originalText) {
                        button.textContent = button.dataset.originalText;
                    }
                }
            },

            // Show skeleton loading in a container
            showSkeleton(container, rows = 3) {
                if (!container) return;
                container.innerHTML = Array(rows).fill('')
                    .map(() => '<div class="skeleton skeleton-row"></div>')
                    .join('');
            },

            // Wrap async operation with loading state
            async wrap(asyncFn, message = 'Loading...') {
                this.show(message);
                try {
                    return await asyncFn();
                } finally {
                    this.hide(message);
                }
            }
        };

        // Update connection status display
        function updateConnectionStatus(state) {
            const status = document.getElementById('connection-status');
            if (!status) return;

            switch(state) {
                case 'connected':
                    status.className = 'connection-status connected';
                    status.innerHTML = '<div class="connection-dot"></div><span>Online</span>';
                    break;
                case 'disconnected':
                    status.className = 'connection-status disconnected';
                    status.innerHTML = '<div class="connection-dot"></div><span>Offline</span>';
                    break;
                case 'connecting':
                    status.className = 'connection-status connecting';
                    status.innerHTML = '<div class="connection-dot pulsing"></div><span>Connecting...</span>';
                    break;
                case 'reconnecting':
                    status.className = 'connection-status reconnecting';
                    status.innerHTML = '<div class="connection-dot pulsing"></div><span>Reconnecting...</span>';
                    break;
                default:
                    // Legacy boolean support
                    if (state === true) {
                        status.className = 'connection-status connected';
                        status.innerHTML = '<div class="connection-dot"></div><span>Online</span>';
                    } else {
                        status.className = 'connection-status disconnected';
                        status.innerHTML = '<div class="connection-dot"></div><span>Offline</span>';
                    }
            }
        }

        // Monitor Firebase connection state
        function initConnectionMonitor() {
            if (!isFirebaseReady || !db) return;

            const connectedRef = db.ref('.info/connected');
            connectedRef.on('value', (snap) => {
                if (snap.val() === true) {
                    updateConnectionStatus('connected');
                } else {
                    updateConnectionStatus('disconnected');
                }
            });
        }

        // ============ LOBBY FUNCTIONS ============

        // ============ PASS & PLAY MODE ============

        let passPlayState = {
            active: false,
            redWord: '',
            blueWord: '',
            redPlannedWords: ['', '', ''],
            bluePlannedWords: ['', '', ''],
            redRevealed: [false, false, false, false, false],
            blueRevealed: [false, false, false, false, false],
            redGuessedLetters: new Set(),
            blueGuessedLetters: new Set(),
            currentPlayer: null
        };

        function startPassAndPlay() {
            passPlayState.active = true;
            passPlayState.redWord = '';
            passPlayState.blueWord = '';
            passPlayState.redPlannedWords = ['', '', ''];
            passPlayState.bluePlannedWords = ['', '', ''];
            passPlayState.redRevealed = [false, false, false, false, false];
            passPlayState.blueRevealed = [false, false, false, false, false];
            passPlayState.redGuessedLetters = new Set();
            passPlayState.blueGuessedLetters = new Set();
            
            gameState.round = 1;
            gameState.myWins = 0;
            gameState.opponentWins = 0;
            gameState.status = 'setup'; // FIX: Set status so continueAsPlayer works
            document.getElementById('red-wins').textContent = '0';
            document.getElementById('blue-wins').textContent = '0';
            document.getElementById('round-number').textContent = '1';
            
            // Hide connection status in pass & play
            document.getElementById('connection-status').style.display = 'none';
            
            // Red picks mode
            gameState.myRole = 'red';
            passPlayState.currentPlayer = 'red'; // FIX: Also set currentPlayer
            showModeSelectOrDefault();
        }

        function continueAsPlayer(player) {
            passPlayState.currentPlayer = player;
            gameState.myRole = player;
            
            // Load this player's state
            if (player === 'red') {
                gameState.myWord = passPlayState.redWord;
                gameState.opponentWord = passPlayState.blueWord;
                gameState.myRevealed = [...passPlayState.redRevealed];
                gameState.opponentRevealed = [...passPlayState.blueRevealed];
                gameState.myGuessedLetters = new Set(passPlayState.redGuessedLetters);
                gameState.myPlannedWords = [...passPlayState.redPlannedWords];
                gameState.opponentPlannedWords = [...passPlayState.bluePlannedWords];
            } else {
                gameState.myWord = passPlayState.blueWord;
                gameState.opponentWord = passPlayState.redWord;
                gameState.myRevealed = [...passPlayState.blueRevealed];
                gameState.opponentRevealed = [...passPlayState.redRevealed];
                gameState.myGuessedLetters = new Set(passPlayState.blueGuessedLetters);
                gameState.myPlannedWords = [...passPlayState.bluePlannedWords];
                gameState.opponentPlannedWords = [...passPlayState.redPlannedWords];
            }
            
            gameState.myScore = calculateWordScore(gameState.myWord);
            gameState.opponentScore = calculateWordScore(gameState.opponentWord);
            
            // Determine what phase we should be in
            if (gameState.status === 'setup') {
                if (gameState.mode === 'advanced') {
                    startWordPlanning();
                } else {
                    startWordInput();
                }
            } else if (gameState.status === 'battle') {
                gameState.isMyTurn = true;
                setupBattleUI();
                showPhase('phase-battle');
            }
        }

        function savePlayerState() {
            // Save current player's state back to passPlayState
            if (passPlayState.currentPlayer === 'red') {
                passPlayState.redWord = gameState.myWord;
                passPlayState.redRevealed = [...gameState.myRevealed];
                passPlayState.blueRevealed = [...gameState.opponentRevealed];
                passPlayState.redGuessedLetters = new Set(gameState.myGuessedLetters);
                passPlayState.redPlannedWords = [...gameState.myPlannedWords];
            } else {
                passPlayState.blueWord = gameState.myWord;
                passPlayState.blueRevealed = [...gameState.myRevealed];
                passPlayState.redRevealed = [...gameState.opponentRevealed];
                passPlayState.blueGuessedLetters = new Set(gameState.myGuessedLetters);
                passPlayState.bluePlannedWords = [...gameState.myPlannedWords];
            }
        }

        function passToOtherPlayer() {
            savePlayerState();
            const otherPlayer = passPlayState.currentPlayer === 'red' ? 'blue' : 'red';
            showPhase(`phase-pass-${otherPlayer}`);
        }

        // ============ ONLINE MULTIPLAYER ============

        function createGame() {
            gameState.gameCode = generateGameCode();
            gameState.myRole = 'red';
            gameState.status = 'waiting';
            gameState.isPublic = false;

            // Determine if this is a rated game (both players signed in)
            gameState.isRatedGame = currentUser !== null;

            document.getElementById('display-game-code').textContent = gameState.gameCode;
            // Show private game info, hide public game info
            document.getElementById('private-game-info').style.display = 'block';
            document.getElementById('public-game-info').style.display = 'none';

            LoadingManager.show('Creating Game...');

            if (isFirebaseReady) {
                // Create game in Firebase
                gameRef = db.ref('games/' + gameState.gameCode);
                gameRef.set({
                    status: 'waiting',
                    mode: null,
                    round: 1,
                    currentTurn: null,
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    isRated: gameState.isRatedGame,
                    red: {
                        deviceId: deviceId,
                        odid: currentUser ? currentUser.uid : null,
                        displayName: currentUser ? currentUser.displayName : 'Guest',
                        rating: userProfile.rating,
                        word: '',
                        score: 0,
                        wins: 0,
                        revealed: [false, false, false, false, false],
                        guessedLetters: [],
                        connected: true,
                        ready: false,
                        lastSeen: firebase.database.ServerValue.TIMESTAMP
                    },
                    blue: {
                        deviceId: '',
                        odid: null,
                        displayName: 'Waiting...',
                        rating: 1200,
                        word: '',
                        score: 0,
                        wins: 0,
                        revealed: [false, false, false, false, false],
                        guessedLetters: [],
                        connected: false,
                        ready: false
                    }
                });

                // Listen for opponent joining
                gameRef.on('value', handleGameUpdate);

                // Handle disconnect
                gameRef.child('red/connected').onDisconnect().set(false);

                // Save active game for reconnection
                saveActiveGame();
                startDisconnectMonitoring();

                LoadingManager.hide('Creating Game...');
                showPhase('phase-create-waiting');
            } else {
                LoadingManager.hide('Creating Game...');
                showPhase('phase-create-waiting');
                // Demo mode - simulate opponent joining after 3 seconds
                showMessage('Demo mode: Simulating opponent...', 'info');
                setTimeout(() => {
                    showMessage('Opponent joined!', 'success');
                    showModeSelectOrDefault();
                }, 3000);
            }
        }

        // ============ PUBLIC GAME LOBBY ============
        
        let lobbyRef = null;
        let lobbyListener = null;
        
        function showCreateOptions() {
            showPhase('phase-create-options');
        }
        
        function showFindGame() {
            showPhase('phase-find-game');
            loadPublicGames();
        }
        
        function createPublicGame() {
            gameState.gameCode = generateGameCode();
            gameState.myRole = 'red';
            gameState.status = 'waiting';
            gameState.isRatedGame = currentUser !== null;
            gameState.isPublic = true;
            
            document.getElementById('display-game-code').textContent = gameState.gameCode;
            // Show public game info, hide private game info
            document.getElementById('private-game-info').style.display = 'none';
            document.getElementById('public-game-info').style.display = 'block';
            showPhase('phase-create-waiting');
            
            if (isFirebaseReady) {
                // Create game in Firebase
                gameRef = db.ref('games/' + gameState.gameCode);
                gameRef.set({
                    status: 'waiting',
                    mode: null,
                    round: 1,
                    currentTurn: null,
                    createdAt: firebase.database.ServerValue.TIMESTAMP,
                    isRated: gameState.isRatedGame,
                    isPublic: true,
                    red: {
                        deviceId: deviceId,
                        odid: currentUser ? currentUser.uid : null,
                        displayName: currentUser ? currentUser.displayName : 'Guest',
                        photoURL: currentUser ? currentUser.photoURL : null,
                        rating: userProfile.rating,
                        word: '',
                        score: 0,
                        wins: 0,
                        revealed: [false, false, false, false, false],
                        guessedLetters: [],
                        connected: true,
                        ready: false,
                        lastSeen: firebase.database.ServerValue.TIMESTAMP
                    },
                    blue: {
                        deviceId: '',
                        odid: null,
                        displayName: 'Waiting...',
                        rating: 1200,
                        word: '',
                        score: 0,
                        wins: 0,
                        revealed: [false, false, false, false, false],
                        guessedLetters: [],
                        connected: false,
                        ready: false
                    }
                });
                
                // Add to public lobby
                const lobbyEntry = db.ref('lobby/' + gameState.gameCode);
                console.log('Creating lobby entry at:', 'lobby/' + gameState.gameCode);
                lobbyEntry.set({
                    gameCode: gameState.gameCode,
                    hostId: currentUser ? currentUser.uid : deviceId,
                    hostName: currentUser ? currentUser.displayName : 'Guest',
                    hostRating: userProfile.rating,
                    hostPhotoURL: currentUser ? currentUser.photoURL : null,
                    isRated: gameState.isRatedGame,
                    createdAt: firebase.database.ServerValue.TIMESTAMP
                }).then(() => {
                    console.log('Lobby entry created successfully!');
                }).catch((error) => {
                    console.error('Failed to create lobby entry:', error);
                    showMessage('Failed to list game publicly: ' + error.message, 'error');
                });
                
                // Remove from lobby when game starts or is cancelled
                lobbyEntry.onDisconnect().remove();
                
                // Listen for opponent joining
                gameRef.on('value', (snapshot) => {
                    handleGameUpdate(snapshot);
                    
                    // Remove from lobby when opponent joins
                    const game = snapshot.val();
                    if (game && game.status !== 'waiting') {
                        lobbyEntry.remove();
                    }
                });
                
                // Handle disconnect
                gameRef.child('red/connected').onDisconnect().set(false);
                
                // Save active game for reconnection
                saveActiveGame();
                startDisconnectMonitoring();
            } else {
                // Demo mode
                showMessage('Demo mode: Simulating opponent...', 'info');
                setTimeout(() => {
                    showMessage('Opponent joined!', 'success');
                    showModeSelectOrDefault();
                }, 3000);
            }
        }
        
        function loadPublicGames() {
            const listEl = document.getElementById('public-games-list');
            const noGamesEl = document.getElementById('no-games-message');

            console.log('=== LOADING PUBLIC GAMES ===');
            console.log('isFirebaseReady:', isFirebaseReady);
            console.log('currentUser:', currentUser ? currentUser.uid : 'null');
            console.log('deviceId:', deviceId);

            // Show skeleton loading
            LoadingManager.showSkeleton(listEl, 3);
            noGamesEl.style.display = 'none';
            
            if (!isFirebaseReady) {
                // Demo mode - show sample games
                console.log('Demo mode - showing sample games');
                setTimeout(() => {
                    renderPublicGames([
                        {
                            gameCode: 'DEMO1',
                            hostName: 'DemoPlayer',
                            hostRating: 1350,
                            createdAt: Date.now() - 30000
                        },
                        {
                            gameCode: 'DEMO2',
                            hostName: 'TestUser',
                            hostRating: 1200,
                            createdAt: Date.now() - 90000
                        }
                    ]);
                }, 1000);
                return;
            }
            
            // Clean up previous listener
            if (lobbyListener) {
                console.log('Cleaning up previous lobby listener');
                db.ref('lobby').off('value', lobbyListener);
                lobbyListener = null;
            }
            
            // Listen to lobby changes
            const lobbyRef = db.ref('lobby');
            console.log('Setting up lobby listener on:', lobbyRef.toString());
            
            lobbyListener = lobbyRef.on('value', (snapshot) => {
                console.log('=== LOBBY SNAPSHOT ===');
                console.log('Exists:', snapshot.exists());
                console.log('Num children:', snapshot.numChildren());
                
                const games = [];
                const now = Date.now();
                const maxAge = 10 * 60 * 1000; // 10 minutes max
                
                if (snapshot.exists()) {
                    snapshot.forEach((child) => {
                        const game = child.val();
                        console.log('Found game:', child.key, 'hostId:', game.hostId, 'hostName:', game.hostName);
                        const age = now - (game.createdAt || 0);
                        
                        // Skip expired games or own games
                        const myId = currentUser ? currentUser.uid : deviceId;
                        console.log('Comparing hostId:', game.hostId, 'vs myId:', myId, 'match:', game.hostId === myId);
                        
                        if (age < maxAge && game.hostId !== myId) {
                            console.log('Adding game to list:', child.key);
                            games.push({
                                ...game,
                                gameCode: child.key
                            });
                        } else if (age >= maxAge) {
                            // Clean up expired lobby entry
                            console.log('Removing expired lobby entry:', child.key);
                            child.ref.remove();
                        } else {
                            console.log('Skipping own game:', child.key);
                        }
                    });
                }
                
                // Sort by most recent first
                games.sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
                
                console.log('Rendering', games.length, 'public games');
                renderPublicGames(games);
            }, (error) => {
                console.error('Lobby listener error:', error);
                listEl.innerHTML = `<div style="color: #f44; padding: 20px; text-align: center;">Error loading games: ${error.message}</div>`;
            });
        }
        
        function renderPublicGames(games) {
            const listEl = document.getElementById('public-games-list');
            const noGamesEl = document.getElementById('no-games-message');
            
            if (games.length === 0) {
                listEl.innerHTML = '';
                noGamesEl.style.display = 'block';
                return;
            }
            
            noGamesEl.style.display = 'none';
            
            listEl.innerHTML = games.map(game => `
                <div class="game-card" data-code="${game.gameCode}">
                    <div class="game-card-info">
                        <div class="game-card-avatar">
                            ${game.hostPhotoURL 
                                ? `<img src="${game.hostPhotoURL}" alt="${game.hostName}">`
                                : game.hostName.charAt(0).toUpperCase()
                            }
                        </div>
                        <div class="game-card-details">
                            <div class="game-card-host">${escapeHtml(game.hostName)}</div>
                            <div class="game-card-meta">
                                <span class="game-card-rating">â­ ${game.hostRating || 1200}</span>
                                <span class="game-card-time">${formatTimeAgo(game.createdAt)}</span>
                            </div>
                        </div>
                    </div>
                    <button class="game-card-join" onclick="joinPublicGame('${game.gameCode}')">Join</button>
                </div>
            `).join('');
        }
        
        function joinPublicGame(gameCode) {
            // Stop listening to lobby
            if (lobbyListener) {
                db.ref('lobby').off('value', lobbyListener);
                lobbyListener = null;
            }
            
            // Join the game
            gameState.gameCode = gameCode;
            gameState.myRole = 'blue';
            gameState.isRatedGame = currentUser !== null;
            
            if (isFirebaseReady) {
                gameRef = db.ref('games/' + gameCode);
                
                // Check if game still exists and is waiting
                gameRef.once('value').then(snapshot => {
                    if (!snapshot.exists()) {
                        showMessage('Game no longer exists', 'error');
                        showFindGame();
                        return;
                    }
                    
                    const game = snapshot.val();
                    if (game.status !== 'waiting') {
                        showMessage('Game already started', 'error');
                        showFindGame();
                        return;
                    }
                    
                    // Join the game
                    gameRef.child('blue').update({
                        deviceId: deviceId,
                        odid: currentUser ? currentUser.uid : null,
                        displayName: currentUser ? currentUser.displayName : 'Guest',
                        rating: userProfile.rating,
                        connected: true,
                        lastSeen: firebase.database.ServerValue.TIMESTAMP
                    });
                    
                    // Remove from lobby
                    db.ref('lobby/' + gameCode).remove();
                    
                    // Game is rated only if both players are signed in
                    const isRated = game.isRated && currentUser !== null;
                    gameRef.child('isRated').set(isRated);
                    gameState.isRatedGame = isRated;
                    
                    // Set status to setup
                    gameRef.child('status').set('setup');
                    
                    // Get opponent info
                    gameState.opponentUserId = game.red.odid;
                    gameState.opponentDisplayName = game.red.displayName || 'Opponent';
                    gameState.opponentUserRating = game.red.rating || 1200;
                    
                    // Listen for game updates
                    gameRef.on('value', handleGameUpdate);
                    
                    // Handle disconnect
                    gameRef.child('blue/connected').onDisconnect().set(false);
                    
                    // Save active game for reconnection
                    saveActiveGame();
                    startDisconnectMonitoring();
                    
                    showMessage('Joined game!', 'success');
                    
                    // Wait for red to select mode
                    showPhase('phase-join-waiting');
                });
            } else {
                // Demo mode
                showMessage('Joined game!', 'success');
                showPhase('phase-mode-select');
            }
        }
        
        function formatTimeAgo(timestamp) {
            const seconds = Math.floor((Date.now() - timestamp) / 1000);
            
            if (seconds < 60) return `${seconds}s ago`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Clean up lobby listener when leaving find game phase
        function cleanupLobbyListener() {
            if (lobbyListener) {
                db.ref('lobby').off('value', lobbyListener);
                lobbyListener = null;
            }
        }

        function showJoinGame() {
            showPhase('phase-join');
            setupCodeInput();
        }

        function setupCodeInput() {
            const container = document.getElementById('code-input');
            const inputs = container.querySelectorAll('.code-letter');
            
            inputs.forEach((input, index) => {
                input.value = '';
                
                input.addEventListener('input', (e) => {
                    const value = e.target.value.toUpperCase();
                    if (/^[A-Z]$/.test(value)) {
                        e.target.value = value;
                        if (index < 4) inputs[index + 1].focus();
                        checkCodeComplete();
                    } else {
                        e.target.value = '';
                    }
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace' && !e.target.value && index > 0) {
                        inputs[index - 1].focus();
                    }
                });
            });

            inputs[0].focus();
        }

        function checkCodeComplete() {
            const inputs = document.querySelectorAll('#code-input .code-letter');
            let code = '';
            inputs.forEach(input => code += input.value);
            document.getElementById('join-btn').disabled = code.length !== 5;
        }

        function getEnteredCode() {
            const inputs = document.querySelectorAll('#code-input .code-letter');
            let code = '';
            inputs.forEach(input => code += input.value);
            return code.toUpperCase();
        }

        function joinGame() {
            const code = getEnteredCode();
            gameState.gameCode = code;
            gameState.myRole = 'blue';

            LoadingManager.show('Joining Game...');

            if (isFirebaseReady) {
                // Check if game exists
                gameRef = db.ref('games/' + code);
                gameRef.once('value').then(snapshot => {
                    if (snapshot.exists()) {
                        const game = snapshot.val();
                        if (game.status === 'waiting' && !game.blue.deviceId) {
                            // Store opponent info
                            gameState.opponentUserId = game.red.odid;
                            gameState.opponentDisplayName = game.red.displayName || 'Opponent';
                            gameState.opponentUserRating = game.red.rating || 1200;

                            // Game is rated only if both players are signed in
                            gameState.isRatedGame = game.isRated && currentUser !== null;

                            // Join the game
                            gameRef.child('blue').update({
                                deviceId: deviceId,
                                odid: currentUser ? currentUser.uid : null,
                                displayName: currentUser ? currentUser.displayName : 'Guest',
                                rating: userProfile.rating,
                                connected: true,
                                lastSeen: firebase.database.ServerValue.TIMESTAMP
                            });

                            // Update isRated if blue is not signed in
                            if (!currentUser) {
                                gameRef.child('isRated').set(false);
                            }

                            gameRef.child('status').set('setup');

                            LoadingManager.hide('Joining Game...');
                            showPhase('phase-join-waiting');
                            showMessage('Joined game!', 'success');

                            // Listen for game updates
                            gameRef.on('value', handleGameUpdate);
                            gameRef.child('blue/connected').onDisconnect().set(false);

                            // Save active game for reconnection
                            saveActiveGame();
                            startDisconnectMonitoring();
                        } else {
                            LoadingManager.hide('Joining Game...');
                            showMessage('Game not available', 'error');
                        }
                    } else {
                        LoadingManager.hide('Joining Game...');
                        showMessage('Game not found', 'error');
                    }
                }).catch(error => {
                    LoadingManager.hide('Joining Game...');
                    handleError(error, 'Join game');
                });
            } else {
                // Demo mode
                LoadingManager.hide('Joining Game...');
                showPhase('phase-join-waiting');
                showMessage('Demo mode: Joined game!', 'success');
                setTimeout(() => {
                    gameState.mode = 'beginner';
                    startWordInput();
                }, 2000);
            }
        }

        function cancelGame() {
            // Clean up reconnection tracking
            clearActiveGame();
            stopDisconnectMonitoring();
            
            if (gameRef) {
                gameRef.remove();
                gameRef.off();
                gameRef = null;
            }
            gameState = {
                gameCode: null,
                myRole: null,
                mode: 'beginner',
                status: 'lobby',
                round: 1,
                myWord: '',
                opponentWord: '',
                myScore: 0,
                opponentScore: 0,
                myWins: 0,
                opponentWins: 0,
                currentTurn: null,
                myRevealed: [false, false, false, false, false],
                myGuessedLetters: new Set(),
                isMyTurn: false,
                showingRoundResult: false,
                isPublic: false
            };
            
            // Hide game UI elements
            document.getElementById('scoreboard').style.display = 'none';
            document.getElementById('mode-badge-container').style.display = 'none';
            
            showPhase('phase-lobby');
        }

        // ============ GAME UPDATE HANDLER ============

        // Helper function to trigger battle start (used by both Red and Blue)
        function triggerBattleStart(game) {
            if (!gameRef) return;
            
            console.log('triggerBattleStart called');
            console.log('Game status:', game.status);
            console.log('Red ready:', game.red?.ready, 'Blue ready:', game.blue?.ready);
            console.log('Red word:', game.red?.word, 'Blue word:', game.blue?.word);
            
            // Calculate who goes first (lower score, Red wins ties)
            const redScore = game.red?.score || 0;
            const blueScore = game.blue?.score || 0;
            const firstTurn = redScore <= blueScore ? 'red' : 'blue';
            
            console.log('Triggering battle transition... First turn:', firstTurn);
            gameRef.update({
                status: 'battle',
                currentTurn: firstTurn
            });
        }

        function handleGameUpdate(snapshot) {
            if (!snapshot.exists()) return;
            
            const game = snapshot.val();
            console.log('=== GAME UPDATE ===');
            console.log('Firebase game.status:', game.status, 'round:', game.round, 'mode:', game.mode);
            console.log('Local gameState.status:', gameState.status, 'round:', gameState.round, 'mode:', gameState.mode);
            console.log('gameState.myRole:', gameState.myRole);
            console.log('gameState.showingRoundResult:', gameState.showingRoundResult);
            console.log('Red ready:', game.red?.ready, 'Blue ready:', game.blue?.ready);
            console.log('Red readyForNextRound:', game.red?.readyForNextRound, 'Blue readyForNextRound:', game.blue?.readyForNextRound);
            
            // Current active phase for debugging
            const phases = ['phase-lobby', 'phase-create-waiting', 'phase-join-waiting', 'phase-mode-select', 
                           'phase-word-planning', 'phase-waiting-plan', 'phase-word-input', 'phase-waiting-word',
                           'phase-battle', 'phase-waiting-turn', 'phase-round-result', 'phase-match-result'];
            const activePhase = phases.find(p => document.getElementById(p)?.classList.contains('active'));
            console.log('Active phase:', activePhase);
            
            // Check for opponent forfeit
            if (game.forfeitedBy && game.forfeitedBy !== gameState.myRole && gameState.status !== 'finished') {
                console.log('=== OPPONENT FORFEITED ===');
                handleOpponentForfeit();
                return;
            }
            
            // Check if opponent joined (Red sees Blue join)
            if (gameState.myRole === 'red' && game.status === 'setup' && gameState.status === 'waiting') {
                // Capture opponent info
                gameState.opponentUserId = game.blue.odid;
                gameState.opponentDisplayName = game.blue.displayName || 'Opponent';
                gameState.opponentUserRating = game.blue.rating || 1200;
                gameState.isRatedGame = game.isRated;
                
                showMessage('Opponent joined!', 'success');
                SoundManager.opponentJoined();
                gameState.status = 'setup';
                showModeSelectOrDefault();
            }

            // Mode was selected (for blue player)
            // This handles both initial game start AND rematch
            if (gameState.myRole === 'blue' && game.mode && game.round === 1) {
                console.log('Blue mode check - gameState.status:', gameState.status, 'game.blue.ready:', game.blue?.ready, 'game.status:', game.status);
                
                // Check if Blue is already in a word entry phase (don't re-trigger!)
                const planningPhase = document.getElementById('phase-word-planning');
                const waitingPlanPhase = document.getElementById('phase-waiting-plan');
                const wordInputPhase = document.getElementById('phase-word-input');
                const waitingWordPhase = document.getElementById('phase-waiting-word');
                
                const alreadyInEntryPhase = 
                    (planningPhase && planningPhase.classList.contains('active')) ||
                    (waitingPlanPhase && waitingPlanPhase.classList.contains('active')) ||
                    (wordInputPhase && wordInputPhase.classList.contains('active')) ||
                    (waitingWordPhase && waitingWordPhase.classList.contains('active'));
                
                if (alreadyInEntryPhase) {
                    console.log('Blue already in entry phase, not re-triggering');
                } else {
                    // Blue should enter word input if:
                    // 1. They haven't submitted a word yet (not ready)
                    // 2. They're not already in battle
                    // 3. Game status is setup or rematch_starting (not finished)
                    const blueReady = game.blue?.ready === true;
                    const inBattle = gameState.status === 'battle';
                    const gameIsActive = game.status === 'setup' || game.status === 'rematch_starting';
                    const waitingForMode = gameState.status === 'waiting_rematch' || gameState.status === 'joining';
                    
                    if (!blueReady && !inBattle && (gameIsActive || waitingForMode)) {
                        console.log('Blue starting word entry - mode:', game.mode);
                        gameState.mode = game.mode;
                        gameState.status = 'setup';
                        
                        if (game.mode === 'advanced') {
                            forceStartWordPlanning();
                        } else {
                            forceStartWordInput();
                        }
                    } else {
                        console.log('Blue skipping word entry - blueReady:', blueReady, 'inBattle:', inBattle, 'gameIsActive:', gameIsActive, 'waitingForMode:', waitingForMode);
                        // If we submitted but aren't in battle yet, show waiting screen
                        if (blueReady && game.status !== 'battle') {
                            if (game.mode === 'advanced') {
                                showPhase('phase-waiting-plan');
                            } else {
                                showPhase('phase-waiting-word');
                            }
                        }
                    }
                }
            }
            
            // Check if both players have submitted words (fixes race condition)
            // Red triggers primarily, but Blue can also trigger as fallback
            const bothPlayersReady = game.red && game.blue && 
                game.red.ready === true && game.blue.ready === true &&
                game.status !== 'battle' && game.status !== 'round_over' && game.status !== 'finished';
            
            console.log('Both ready check:', 
                'myRole:', gameState.myRole,
                'red.ready:', game.red?.ready,
                'blue.ready:', game.blue?.ready,
                'status:', game.status,
                'bothPlayersReady:', bothPlayersReady);
            
            if (bothPlayersReady) {
                // Red triggers immediately, Blue triggers after a short delay as fallback
                if (gameState.myRole === 'red') {
                    console.log('=== BOTH PLAYERS READY (Red triggering) ===');
                    triggerBattleStart(game);
                } else {
                    // Blue waits 2 seconds then triggers if still not in battle
                    // This handles cases where Red's client is slow/disconnected
                    console.log('=== BOTH PLAYERS READY (Blue will trigger as fallback in 2s) ===');
                    setTimeout(() => {
                        // Re-check game state before triggering
                        if (gameRef) {
                            gameRef.once('value').then(snapshot => {
                                const currentGame = snapshot.val();
                                if (currentGame && currentGame.status !== 'battle' && 
                                    currentGame.red?.ready && currentGame.blue?.ready) {
                                    console.log('=== Blue fallback triggering battle ===');
                                    triggerBattleStart(currentGame);
                                }
                            });
                        }
                    }, 2000);
                }
            }
            
            // Both players ready - start battle
            const battleStartCondition = game.status === 'battle' && gameState.status !== 'battle';
            console.log('Battle start check:',
                'game.status===battle:', game.status === 'battle',
                'gameState.status:', gameState.status,
                'RESULT:', battleStartCondition);
            
            if (battleStartCondition) {
                console.log('=== STARTING BATTLE ===');
                console.log('My role:', gameState.myRole);
                gameState.status = 'battle';
                const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
                
                // Get opponent's word (and planned words in advanced mode)
                if (gameState.mode === 'advanced' && game[opponent].plannedWords) {
                    gameState.opponentPlannedWords = game[opponent].plannedWords;
                    gameState.opponentWord = game[opponent].plannedWords[gameState.round - 1];
                } else {
                    gameState.opponentWord = game[opponent].word;
                }
                gameState.opponentScore = calculateWordScore(gameState.opponentWord);
                
                // Use Firebase currentTurn if available, otherwise calculate
                if (game.currentTurn) {
                    gameState.currentTurn = game.currentTurn;
                } else {
                    // Fallback: calculate based on scores (Red wins ties)
                    const redScore = game.red.score || calculateWordScore(game.red.word);
                    const blueScore = game.blue.score || calculateWordScore(game.blue.word);
                    gameState.currentTurn = redScore <= blueScore ? 'red' : 'blue';
                }
                
                gameState.isMyTurn = gameState.currentTurn === gameState.myRole;
                
                console.log('Current turn:', gameState.currentTurn, 'Is my turn:', gameState.isMyTurn);
                
                startBattle();
            }
            
            // Turn updates during battle
            if (game.status === 'battle' && gameState.status === 'battle') {
                updateBattleFromGame(game);
            }
            
            // Round finished - only process if we were in battle
            if (game.status === 'round_over' && (gameState.status === 'battle' || gameState.status === 'round_over')) {
                console.log('=== ROUND_OVER STATUS DETECTED ===');
                console.log('gameState.status:', gameState.status);
                handleRoundOver(game);
            }
            
            // Check if both players ready for next round
            if (game.status === 'round_over' && game.red && game.blue &&
                game.red.readyForNextRound && game.blue.readyForNextRound) {
                console.log('=== BOTH READY FOR NEXT ROUND ===');
                console.log('Red readyForNextRound:', game.red.readyForNextRound);
                console.log('Blue readyForNextRound:', game.blue.readyForNextRound);
                console.log('gameState.showingRoundResult:', gameState.showingRoundResult);
                
                // Clear the flag since both players have seen the result
                gameState.showingRoundResult = false;
                
                // Red player triggers the next round setup
                if (gameState.myRole === 'red') {
                    const nextRoundNum = gameState.round + 1;
                    console.log('Red triggering round', nextRoundNum, 'setup');
                    
                    // Reset ready flags and start next round
                    gameRef.update({
                        status: 'setup',
                        round: nextRoundNum,
                        'red/ready': false,
                        'red/readyForNextRound': false,
                        'red/word': null,
                        'red/revealed': null,
                        'blue/ready': false,
                        'blue/readyForNextRound': false,
                        'blue/word': null,
                        'blue/revealed': null,
                        currentTurn: null
                    });
                }
            }
            
            // Detect round change and start new round input
            // Skip if currently showing round result to ensure player sees it
            const newRoundCondition = game.status === 'setup' && game.round && game.round > gameState.round && !gameState.showingRoundResult;
            console.log('New round check:', 'game.status===setup:', game.status === 'setup', 
                        'game.round:', game.round, 'gameState.round:', gameState.round,
                        'round>:', game.round > gameState.round, 
                        '!showingRoundResult:', !gameState.showingRoundResult,
                        'RESULT:', newRoundCondition);
            
            if (newRoundCondition) {
                console.log('=== NEW ROUND DETECTED ===', game.round);
                console.log('gameState.myRole:', gameState.myRole);
                console.log('gameState.mode:', gameState.mode);
                gameState.round = game.round;
                gameState.myRevealed = [false, false, false, false, false];
                gameState.opponentRevealed = [false, false, false, false, false];
                gameState.myGuessedLetters = new Set();
                gameState.myWord = ''; // Clear previous word
                gameState.opponentWord = '';
                gameState.status = 'setup';
                
                // Reset battle UI for new round
                resetBattleUI();
                
                document.getElementById('round-number').textContent = gameState.round;
                
                if (gameState.mode === 'advanced') {
                    // Validate planned words exist before loading
                    if (!gameState.myPlannedWords || !Array.isArray(gameState.myPlannedWords) ||
                        gameState.myPlannedWords.length < gameState.round ||
                        !gameState.myPlannedWords[gameState.round - 1]) {
                        console.error('Advanced mode: Missing planned words for round', gameState.round);
                        console.log('myPlannedWords:', gameState.myPlannedWords);

                        // Try to recover from Firebase
                        if (gameRef) {
                            gameRef.child(gameState.myRole + '/plannedWords').once('value').then(snapshot => {
                                if (snapshot.exists()) {
                                    gameState.myPlannedWords = snapshot.val();
                                    console.log('Recovered planned words from Firebase:', gameState.myPlannedWords);

                                    // Now load the word
                                    if (gameState.myPlannedWords[gameState.round - 1]) {
                                        gameState.myWord = gameState.myPlannedWords[gameState.round - 1];
                                        gameState.myScore = calculateWordScore(gameState.myWord);
                                        gameRef.child(gameState.myRole).update({
                                            word: gameState.myWord,
                                            score: gameState.myScore,
                                            ready: true
                                        });
                                        showPhase('phase-waiting-word');
                                    } else {
                                        showMessage('Error: Could not load planned word. Please restart the game.', 'error');
                                        showPhase('phase-lobby');
                                    }
                                } else {
                                    showMessage('Error: Planned words not found. Please restart the game.', 'error');
                                    showPhase('phase-lobby');
                                }
                            });
                        }
                        return; // Exit early, will continue after Firebase callback
                    }

                    // Load next planned word
                    gameState.myWord = gameState.myPlannedWords[gameState.round - 1];
                    gameState.myScore = calculateWordScore(gameState.myWord);

                    // Submit word for new round
                    gameRef.child(gameState.myRole).update({
                        word: gameState.myWord,
                        score: gameState.myScore,
                        ready: true
                    });
                    showPhase('phase-waiting-word');
                } else {
                    // Beginner mode: enter new word
                    // Force transition - bypass guards since this is a new round
                    forceStartWordInput();
                }
            }
            
            // Match finished - only process if we were in battle or round_over
            if (game.status === 'finished' && gameState.status !== 'lobby' && gameState.status !== 'setup' && gameState.status !== 'waiting') {
                handleMatchOver(game);
            }
            
            // Check if both players want rematch
            if (game.status === 'finished' && game.red && game.blue &&
                game.red.wantsRematch && game.blue.wantsRematch) {
                console.log('=== BOTH PLAYERS WANT REMATCH ===');
                startRematch();
            }
            
            // Check if opponent wants rematch while we're still deciding
            if (game.status === 'finished' && game.red && game.blue) {
                const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
                const me = gameState.myRole;

                if (game[opponent].wantsRematch && !game[me].wantsRematch) {
                    // Opponent is waiting for us - update UI
                    const rematchBtn = document.getElementById('rematch-btn');
                    const rematchNotice = document.getElementById('rematch-notice');
                    if (rematchBtn) {
                        rematchBtn.textContent = 'âœ“ Accept Rematch';
                        rematchBtn.classList.add('pulse-glow');
                    }
                    if (rematchNotice) {
                        rematchNotice.style.display = 'block';
                    }
                    // Play notification sound
                    if (!gameState.rematchNotified) {
                        SoundManager.yourTurn();
                        gameState.rematchNotified = true;
                    }
                } else if (!game[opponent].wantsRematch) {
                    // Reset if opponent cancelled
                    const rematchBtn = document.getElementById('rematch-btn');
                    const rematchNotice = document.getElementById('rematch-notice');
                    if (rematchBtn && rematchBtn.textContent.includes('Accept')) {
                        rematchBtn.textContent = 'Rematch';
                        rematchBtn.classList.remove('pulse-glow');
                    }
                    if (rematchNotice) {
                        rematchNotice.style.display = 'none';
                    }
                    gameState.rematchNotified = false;
                }
            }
            
            // Check if opponent exited
            if (game.red && game.blue) {
                const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
                if (game[opponent].exited) {
                    console.log('=== OPPONENT EXITED ===');
                    showMessage('Opponent left the game', 'info');
                    
                    // Reset UI and return to lobby
                    document.getElementById('match-result-buttons').style.display = 'block';
                    document.getElementById('match-result-waiting').style.display = 'none';
                    resetBattleUI();
                    
                    // Clean up and return to lobby
                    setTimeout(() => {
                        cancelGame();
                    }, 1500);
                }
            }
            
            // Rematch is starting (Blue sees this)
            if (game.status === 'rematch_starting' && gameState.myRole === 'blue') {
                console.log('=== REMATCH STARTING (Blue) ===');
                gameState.round = 1;
                gameState.myWins = 0;
                gameState.opponentWins = 0;
                gameState.status = 'setup';
                
                resetBattleUI();
                document.getElementById('match-result-buttons').style.display = 'block';
                document.getElementById('match-result-waiting').style.display = 'none';
                document.getElementById('round-number').textContent = '1';
                document.getElementById('red-wins').textContent = '0';
                document.getElementById('blue-wins').textContent = '0';
                
                // Wait for Red to pick mode
                showPhase('phase-join-waiting');
                showMessage('Waiting for opponent to pick mode...', 'info');
            }
            
            // Check for opponent disconnect (timeout handling)
            checkOpponentDisconnect(game);
        }

        // ============ MODE SELECTION ============

        function showModeSelectOrDefault() {
            // Check if user has a default mode preference
            if (appSettings.defaultMode === 'ask') {
                showPhase('phase-mode-select');
            } else {
                // Auto-select the default mode
                selectMode(appSettings.defaultMode);
            }
        }
        
        function cancelModeSelect() {
            // For pass & play, just go back to lobby
            if (passPlayState.active) {
                passPlayState.active = false;
                document.getElementById('connection-status').style.display = 'flex';
                showPhase('phase-lobby');
                return;
            }
            
            // For online games, cancel the game
            cancelGame();
        }
        
        function selectMode(mode) {
            gameState.mode = mode;
            
            if (isFirebaseReady && gameRef) {
                // Set both mode and status to ensure proper transition
                gameRef.update({
                    mode: mode,
                    status: 'setup'  // Ensure status is 'setup' for both players
                });
            }
            
            if (mode === 'advanced') {
                startWordPlanning();
            } else {
                startWordInput();
            }
        }

        // ============ ADVANCED WORD PLANNING ============

        function startWordPlanning() {
            console.log('=== startWordPlanning called ===');
            console.log('gameState.myRole:', gameState.myRole);
            
            // Guard against re-triggering while already in planning or waiting phase
            const planningPhase = document.getElementById('phase-word-planning');
            const waitingPlanPhase = document.getElementById('phase-waiting-plan');
            
            if (planningPhase && planningPhase.classList.contains('active')) {
                console.log('Already in word planning phase, skipping re-initialization');
                return;
            }
            
            if (waitingPlanPhase && waitingPlanPhase.classList.contains('active')) {
                console.log('Already submitted plan and waiting, skipping re-initialization');
                return;
            }
            
            // Check if we already submitted our planned words
            if (gameState.myPlannedWords && gameState.myPlannedWords[0] && gameState.myPlannedWords[0].length === 5) {
                console.log('Already have planned words submitted, skipping re-initialization');
                return;
            }
            
            console.log('Proceeding with word planning setup');
            
            document.getElementById('scoreboard').style.display = 'flex';
            document.getElementById('mode-badge-container').style.display = 'block';
            
            const titleEl = document.getElementById('planning-title');
            titleEl.textContent = `${gameState.myRole === 'red' ? 'ðŸ¥Š Red' : 'Blue ðŸ¥Š'} Corner - Plan Your 3 Words`;
            titleEl.className = `phase-title ${gameState.myRole}`;
            
            setupPlanningInputs();
            updateAvailableLetters();
            showPhase('phase-word-planning');
        }
        
        // Force word planning without guards - used for rematch
        function forceStartWordPlanning() {
            console.log('=== forceStartWordPlanning called (bypassing guards) ===');
            
            document.getElementById('scoreboard').style.display = 'flex';
            document.getElementById('mode-badge-container').style.display = 'block';
            
            const titleEl = document.getElementById('planning-title');
            titleEl.textContent = `${gameState.myRole === 'red' ? 'ðŸ¥Š Red' : 'Blue ðŸ¥Š'} Corner - Plan Your 3 Words`;
            titleEl.className = `phase-title ${gameState.myRole}`;
            
            setupPlanningInputs();
            updateAvailableLetters();
            showPhase('phase-word-planning');
        }

        function setupPlanningInputs() {
            for (let round = 1; round <= 3; round++) {
                const container = document.getElementById(`plan-word-${round}`);
                container.innerHTML = '';
                
                for (let i = 0; i < 5; i++) {
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'letter-input';
                    input.maxLength = 1;
                    input.dataset.round = round;
                    input.dataset.index = i;
                    
                    input.addEventListener('input', (e) => handlePlanInput(e, round, i));
                    input.addEventListener('keydown', (e) => handlePlanKeydown(e, round, i));
                    
                    container.appendChild(input);
                }
            }
        }

        function handlePlanInput(e, round, index) {
            const value = e.target.value.toUpperCase();
            if (/^[A-Z]$/.test(value)) {
                e.target.value = value;
                e.target.classList.add('filled');
                
                // Move to next input
                const container = document.getElementById(`plan-word-${round}`);
                const inputs = container.querySelectorAll('.letter-input');
                if (index < 4) {
                    inputs[index + 1].focus();
                } else if (round < 3) {
                    const nextContainer = document.getElementById(`plan-word-${round + 1}`);
                    const nextInputs = nextContainer.querySelectorAll('.letter-input');
                    nextInputs[0].focus();
                }
            } else {
                e.target.value = '';
                e.target.classList.remove('filled');
            }
            
            validatePlan();
            updateAvailableLetters();
        }

        function handlePlanKeydown(e, round, index) {
            if (e.key === 'Backspace' && !e.target.value) {
                if (index > 0) {
                    const container = document.getElementById(`plan-word-${round}`);
                    const inputs = container.querySelectorAll('.letter-input');
                    inputs[index - 1].focus();
                    inputs[index - 1].value = '';
                    inputs[index - 1].classList.remove('filled');
                } else if (round > 1) {
                    const prevContainer = document.getElementById(`plan-word-${round - 1}`);
                    const prevInputs = prevContainer.querySelectorAll('.letter-input');
                    prevInputs[4].focus();
                    prevInputs[4].value = '';
                    prevInputs[4].classList.remove('filled');
                }
                validatePlan();
                updateAvailableLetters();
            }
        }

        function getPlannedWords() {
            const words = [];
            for (let round = 1; round <= 3; round++) {
                const container = document.getElementById(`plan-word-${round}`);
                const inputs = container.querySelectorAll('.letter-input');
                let word = '';
                inputs.forEach(input => word += input.value.toUpperCase());
                words.push(word);
            }
            return words;
        }

        function validatePlan() {
            const words = getPlannedWords();
            const statusEl = document.getElementById('plan-status');
            const submitBtn = document.getElementById('submit-plan-btn');
            
            let errors = [];
            
            // Track letters used across all words (each letter counted once per word it appears in)
            const lettersByWord = [];
            
            // Check each word and highlight invalid ones
            for (let round = 1; round <= 3; round++) {
                const word = words[round - 1];
                const container = document.getElementById(`plan-word-${round}`);
                const inputs = container.querySelectorAll('.letter-input');
                
                // Get unique letters in this word
                const uniqueInWord = new Set();
                for (const letter of word) {
                    if (letter) uniqueInWord.add(letter);
                }
                lettersByWord.push(uniqueInWord);
                
                if (word.length === 5) {
                    if (!VALID_WORDS.has(word)) {
                        errors.push(`"${word}" is not a valid word`);
                        inputs.forEach(input => input.classList.add('invalid'));
                    } else {
                        inputs.forEach(input => input.classList.remove('invalid'));
                    }
                } else {
                    inputs.forEach(input => input.classList.remove('invalid'));
                }
            }
            
            // Check for letters used in multiple words
            const letterWordCount = {};
            const duplicateLetters = new Set();
            
            for (let i = 0; i < lettersByWord.length; i++) {
                for (const letter of lettersByWord[i]) {
                    if (!letterWordCount[letter]) {
                        letterWordCount[letter] = [];
                    }
                    letterWordCount[letter].push(i + 1);
                }
            }
            
            for (const letter in letterWordCount) {
                if (letterWordCount[letter].length > 1) {
                    duplicateLetters.add(letter);
                }
            }
            
            if (duplicateLetters.size > 0) {
                errors.push(`Letters used in multiple words: ${Array.from(duplicateLetters).join(', ')}`);
            }
            
            // Update status
            if (errors.length > 0) {
                statusEl.textContent = errors[0];
                statusEl.className = 'plan-status error';
                submitBtn.disabled = true;
            } else if (words.some(w => w.length < 5)) {
                statusEl.textContent = 'Enter all 3 words';
                statusEl.className = 'plan-status';
                submitBtn.disabled = true;
            } else {
                statusEl.textContent = 'âœ“ All words valid! No letters repeated across words.';
                statusEl.className = 'plan-status success';
                submitBtn.disabled = false;
            }
        }

        function updateAvailableLetters() {
            const words = getPlannedWords();
            
            // Get unique letters from each word, then combine
            const usedLetters = new Set();
            words.forEach(word => {
                const uniqueInWord = new Set(word.split(''));
                uniqueInWord.forEach(letter => {
                    if (letter) usedLetters.add(letter);
                });
            });
            
            const container = document.getElementById('available-letters');
            container.innerHTML = '';
            
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (const letter of alphabet) {
                const chip = document.createElement('div');
                chip.className = 'letter-chip';
                chip.textContent = letter;
                
                if (usedLetters.has(letter)) {
                    chip.classList.add('used');
                } else {
                    chip.classList.add('available');
                }
                
                container.appendChild(chip);
            }
            
            document.getElementById('letters-used-count').textContent = usedLetters.size;
        }

        function submitPlan() {
            console.log('=== submitPlan called ===');
            
            // Prevent double submission
            if (gameState.submittingPlan) {
                console.log('Already submitting plan, ignoring');
                return;
            }
            
            const words = getPlannedWords();
            console.log('Planned words:', words);
            
            gameState.submittingPlan = true;
            gameState.myPlannedWords = words;
            gameState.myWord = words[0]; // Set round 1 word
            gameState.myScore = calculateWordScore(gameState.myWord);
            
            // Pass & Play mode
            if (passPlayState.active) {
                gameState.submittingPlan = false;
                savePlayerState();
                
                if (passPlayState.currentPlayer === 'red') {
                    passPlayState.redPlannedWords = [...words];
                    passPlayState.redWord = words[0];
                    // Pass to blue to plan their words
                    showPhase('phase-pass-blue');
                } else {
                    passPlayState.bluePlannedWords = [...words];
                    passPlayState.blueWord = words[0];
                    // Both plans entered - start battle
                    const redScore = calculateWordScore(passPlayState.redWord);
                    const blueScore = calculateWordScore(passPlayState.blueWord);
                    gameState.currentTurn = redScore <= blueScore ? 'red' : 'blue';
                    gameState.status = 'battle';
                    // Pass to whoever goes first
                    showPhase(`phase-pass-${gameState.currentTurn}`);
                }
                return;
            }
            
            if (isFirebaseReady && gameRef) {
                // Show waiting phase BEFORE Firebase update
                // (Firebase fires listeners synchronously on .update(), which can trigger battle start
                // before this function returns)
                showPhase('phase-waiting-plan');
                
                console.log('Submitting plan to Firebase as', gameState.myRole);
                gameRef.child(gameState.myRole).update({
                    plannedWords: words,
                    word: words[0],
                    score: gameState.myScore,
                    ready: true
                }).then(() => {
                    console.log('Plan submitted successfully');
                    gameState.submittingPlan = false;
                }).catch((err) => {
                    console.error('Plan submission failed:', err);
                    gameState.submittingPlan = false;
                });
                
                // Note: The handleGameUpdate listener will detect when both players are ready
                // and trigger the battle transition (only Red triggers to avoid race)
            } else {
                showPhase('phase-waiting-plan');
            }
            
            // Demo mode: simulate opponent planning after delay
            if (!isFirebaseReady && !passPlayState.active) {
                gameState.submittingPlan = false;
                setTimeout(() => {
                    // Simulate opponent's planned words
                    const demoWordSets = [
                        ['CRANE', 'BLOAT', 'JUMPS'],
                        ['STORM', 'BLADE', 'FUNKY'],
                        ['GHOST', 'REALM', 'WINDY']
                    ];
                    gameState.opponentPlannedWords = demoWordSets[Math.floor(Math.random() * demoWordSets.length)];
                    gameState.opponentWord = gameState.opponentPlannedWords[0];
                    gameState.opponentScore = calculateWordScore(gameState.opponentWord);
                    
                    // Determine who goes first (lower score)
                    const myScore = gameState.myScore;
                    const theirScore = gameState.opponentScore;
                    gameState.currentTurn = myScore <= theirScore ? gameState.myRole : (gameState.myRole === 'red' ? 'blue' : 'red');
                    gameState.isMyTurn = gameState.currentTurn === gameState.myRole;
                    gameState.status = 'battle';
                    
                    showMessage('Opponent ready! Battle begins!', 'success');
                    startBattle();
                }, 2500);
            }
        }

        // ============ WORD INPUT (Beginner Mode) ============

        function startWordInput() {
            console.log('=== startWordInput called ===');
            console.log('gameState.myRole:', gameState.myRole);
            console.log('gameState.myWord:', gameState.myWord);
            
            // Guard against re-triggering while already in word input or waiting phase
            const wordInputPhase = document.getElementById('phase-word-input');
            const waitingWordPhase = document.getElementById('phase-waiting-word');
            
            if (wordInputPhase && wordInputPhase.classList.contains('active')) {
                console.log('Already in word input phase, skipping re-initialization');
                return;
            }
            
            if (waitingWordPhase && waitingWordPhase.classList.contains('active')) {
                console.log('Already submitted word and waiting, skipping re-initialization');
                return;
            }
            
            // Also check if we already have a word submitted this round
            if (gameState.myWord && gameState.myWord.length === 5) {
                console.log('Already have word submitted, skipping re-initialization');
                return;
            }
            
            // Call the actual implementation
            doStartWordInput();
        }
        
        // Force word input without guards - used for new rounds
        function forceStartWordInput() {
            console.log('=== forceStartWordInput called (bypassing guards) ===');
            doStartWordInput();
        }
        
        // Actual word input setup
        function doStartWordInput() {
            console.log('Proceeding with word input setup');
            
            document.getElementById('scoreboard').style.display = 'flex';
            
            // Reset battle UI elements from previous round
            resetBattleUI();
            
            const titleEl = document.getElementById('input-title');
            titleEl.textContent = `${gameState.myRole === 'red' ? 'ðŸ¥Š Red' : 'Blue ðŸ¥Š'} Corner - Enter Your Word`;
            titleEl.className = `phase-title ${gameState.myRole}`;
            
            setupWordInput();
            showPhase('phase-word-input');
            console.log('Now showing phase-word-input');
        }

        function resetBattleUI() {
            // Hide keyboard and solve section
            const keyboard = document.getElementById('keyboard');
            if (keyboard) {
                keyboard.classList.remove('active');
                keyboard.innerHTML = '';
            }
            
            const solveSection = document.getElementById('solve-section');
            if (solveSection) {
                solveSection.classList.remove('active');
            }
            
            const solveInput = document.getElementById('solve-input');
            if (solveInput) {
                solveInput.innerHTML = '';
            }
            
            // Show action buttons (they may have been hidden by Guess Letter or Solve Word)
            const actionButtons = document.getElementById('action-buttons');
            if (actionButtons) {
                actionButtons.style.display = 'flex';
            }
            
            // Clear opponent word display
            const opponentDisplay = document.getElementById('opponent-word-display');
            if (opponentDisplay) {
                opponentDisplay.innerHTML = '';
            }
            
            const waitingDisplay = document.getElementById('waiting-opponent-display');
            if (waitingDisplay) {
                waitingDisplay.innerHTML = '';
            }
        }

        function setupWordInput() {
            const container = document.getElementById('word-input');
            container.innerHTML = '';
            
            for (let i = 0; i < 5; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'letter-input';
                input.maxLength = 1;
                input.dataset.index = i;
                
                input.addEventListener('input', (e) => {
                    const value = e.target.value.toUpperCase();
                    if (/^[A-Z]$/.test(value)) {
                        e.target.value = value;
                        e.target.classList.add('filled');
                        if (i < 4) container.children[i + 1].focus();
                        updateWordScore();
                        validateWord();
                    } else {
                        e.target.value = '';
                        e.target.classList.remove('filled');
                    }
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace' && !e.target.value && i > 0) {
                        container.children[i - 1].focus();
                        container.children[i - 1].value = '';
                        container.children[i - 1].classList.remove('filled');
                        updateWordScore();
                        validateWord();
                    }
                });

                container.appendChild(input);
            }
            
            container.children[0].focus();
        }

        function getEnteredWord() {
            const inputs = document.querySelectorAll('#word-input .letter-input');
            let word = '';
            inputs.forEach(input => word += input.value.toUpperCase());
            return word;
        }

        function calculateWordScore(word) {
            let score = 0;
            for (const letter of word) {
                score += LETTER_VALUES[letter] || 0;
            }
            return score;
        }

        function updateWordScore() {
            const word = getEnteredWord();
            const score = calculateWordScore(word);
            document.getElementById('word-score').textContent = score;
        }

        function validateWord() {
            const word = getEnteredWord();
            const inputs = document.querySelectorAll('#word-input .letter-input');
            const btn = document.getElementById('submit-word-btn');
            
            if (word.length === 5) {
                if (VALID_WORDS.has(word)) {
                    inputs.forEach(input => input.classList.remove('invalid'));
                    btn.disabled = false;
                } else {
                    inputs.forEach(input => input.classList.add('invalid'));
                    btn.disabled = true;
                }
            } else {
                inputs.forEach(input => input.classList.remove('invalid'));
                btn.disabled = true;
            }
        }

        function submitWord() {
            const word = getEnteredWord();
            gameState.myWord = word;
            gameState.myScore = calculateWordScore(word);
            SoundManager.wordSubmit();
            
            // Pass & Play mode
            if (passPlayState.active) {
                savePlayerState();
                
                if (passPlayState.currentPlayer === 'red') {
                    passPlayState.redWord = word;
                    // Pass to blue to enter their word
                    showPhase('phase-pass-blue');
                } else {
                    passPlayState.blueWord = word;
                    // Both words entered - start battle
                    // Determine who goes first
                    const redScore = calculateWordScore(passPlayState.redWord);
                    const blueScore = calculateWordScore(passPlayState.blueWord);
                    gameState.currentTurn = redScore <= blueScore ? 'red' : 'blue';
                    gameState.status = 'battle';
                    // Pass to whoever goes first
                    showPhase(`phase-pass-${gameState.currentTurn}`);
                }
                return;
            }
            
            // Show waiting phase BEFORE Firebase update
            // (Firebase fires listeners synchronously on .update(), which can trigger battle start
            // before this function returns. We need to show waiting first, then let the listener
            // override it with battle phase if both players are ready)
            showPhase('phase-waiting-word');
            
            if (isFirebaseReady && gameRef) {
                console.log('Submitting word to Firebase:', word, 'as', gameState.myRole, 'for round', gameState.round);
                gameRef.child(gameState.myRole).update({
                    word: word,
                    score: gameState.myScore,
                    ready: true
                }).then(() => {
                    console.log('Word submitted successfully for round', gameState.round, '- waiting for opponent...');
                }).catch((err) => {
                    console.error('Word submission failed:', err);
                });
                // Note: The Firebase listener will handle the transition to battle
                // when it detects both players are ready
            }
            
            // Demo mode: simulate opponent word after delay
            if (!isFirebaseReady && !passPlayState.active) {
                setTimeout(() => {
                    const demoWords = ['CRANE', 'STORM', 'BEACH', 'PLANT', 'GHOST'];
                    gameState.opponentWord = demoWords[Math.floor(Math.random() * demoWords.length)];
                    gameState.opponentScore = calculateWordScore(gameState.opponentWord);
                    gameState.currentTurn = gameState.myScore <= gameState.opponentScore ? gameState.myRole : (gameState.myRole === 'red' ? 'blue' : 'red');
                    gameState.isMyTurn = gameState.currentTurn === gameState.myRole;
                    gameState.status = 'battle';
                    startBattle();
                }, 2000);
            }
        }

        // ============ BATTLE ============

        function startBattle() {
            setupBattleUI();

            // Ring the bell! Round starts
            SoundManager.roundStart();

            // Ensure action buttons are visible for the player whose turn it is
            document.getElementById('action-buttons').style.display = 'flex';
            document.getElementById('keyboard').classList.remove('active');
            document.getElementById('solve-section').classList.remove('active');
            
            console.log('startBattle - isMyTurn:', gameState.isMyTurn, 'myRole:', gameState.myRole, 'currentTurn:', gameState.currentTurn);
            
            if (gameState.isMyTurn) {
                showPhase('phase-battle');
            } else {
                showPhase('phase-waiting-turn');
            }
            
            // Start periodic sync check for online games
            if (isFirebaseReady && gameRef && !passPlayState.active) {
                startBattleSyncCheck();
            }
        }
        
        // Periodic check to ensure local state matches Firebase
        let battleSyncInterval = null;
        function startBattleSyncCheck() {
            // Clear any existing interval
            if (battleSyncInterval) {
                clearInterval(battleSyncInterval);
            }
            
            battleSyncInterval = setInterval(() => {
                if (gameState.status !== 'battle' || !gameRef) {
                    clearInterval(battleSyncInterval);
                    battleSyncInterval = null;
                    return;
                }
                
                gameRef.once('value').then(snapshot => {
                    if (!snapshot.exists()) return;
                    const game = snapshot.val();
                    
                    // Check if turn is out of sync
                    if (game.status === 'battle' && game.currentTurn) {
                        const shouldBeMyTurn = game.currentTurn === gameState.myRole;
                        
                        if (shouldBeMyTurn !== gameState.isMyTurn) {
                            console.warn('TURN SYNC FIX: Local isMyTurn:', gameState.isMyTurn, 'should be:', shouldBeMyTurn);
                            gameState.isMyTurn = shouldBeMyTurn;
                            gameState.currentTurn = game.currentTurn;
                            
                            if (gameState.isMyTurn) {
                                cancelSolve();
                                document.getElementById('keyboard').classList.remove('active');
                                document.getElementById('action-buttons').style.display = 'flex';
                                showPhase('phase-battle');
                            } else {
                                showPhase('phase-waiting-turn');
                            }
                            updateBattleStatus();
                        }
                    }
                    
                    // Check if game has ended
                    if (game.status === 'round_over' || game.status === 'finished') {
                        clearInterval(battleSyncInterval);
                        battleSyncInterval = null;
                    }
                });
            }, 3000); // Check every 3 seconds
        }
        
        function stopBattleSyncCheck() {
            if (battleSyncInterval) {
                clearInterval(battleSyncInterval);
                battleSyncInterval = null;
            }
        }

        function setupBattleUI() {
            // Setup opponent word display
            const display = document.getElementById('opponent-word-display');
            const waitingDisplay = document.getElementById('waiting-opponent-display');
            display.innerHTML = '';
            waitingDisplay.innerHTML = '';
            
            for (let i = 0; i < 5; i++) {
                const box = document.createElement('div');
                box.className = 'letter-box';
                box.id = `letter-${i}`;
                
                // Check for matched letters (letters in my word that are also in opponent's word)
                const myLetter = gameState.myWord[i];
                const opponentLetter = gameState.opponentWord[i];
                
                if (gameState.myRevealed[i]) {
                    box.textContent = opponentLetter;
                    box.classList.add('revealed');
                } else if (gameState.myWord.includes(opponentLetter)) {
                    box.textContent = opponentLetter;
                    box.classList.add('matched');
                    gameState.myRevealed[i] = true;
                }
                
                display.appendChild(box);
                waitingDisplay.appendChild(box.cloneNode(true));
            }
            
            // Calculate what opponent can see in MY word (matching letters from their word)
            for (let i = 0; i < 5; i++) {
                const myLetter = gameState.myWord[i];
                if (gameState.opponentWord.includes(myLetter)) {
                    gameState.opponentRevealed[i] = true;
                }
            }
            
            updateRevealedCount();
            
            // Setup keyboard
            setupKeyboard();
            
            // Setup solve input
            setupSolveInput();
            
            // Update status
            updateBattleStatus();
        }

        function updateRevealedCount() {
            const count = gameState.opponentRevealed.filter(r => r).length;
            document.getElementById('revealed-count').textContent = count;
            document.getElementById('waiting-revealed-count').textContent = count;
        }

        function updateBattleStatus() {
            const statusBar = document.getElementById('battle-status');
            const statusText = document.getElementById('battle-status-text');
            
            if (gameState.isMyTurn) {
                statusBar.className = 'status-bar your-turn';
                statusText.textContent = 'ðŸ¥Š Your Turn!';
            } else {
                statusBar.className = 'status-bar opponent-turn';
                statusText.textContent = 'â³ Opponent\'s Turn...';
            }
        }

        function setupKeyboard() {
            const keyboard = document.getElementById('keyboard');
            keyboard.innerHTML = '';
            
            const rows = ['QWERTYUIOP', 'ASDFGHJKL', 'ZXCVBNM'];
            
            rows.forEach(row => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'keyboard-row';
                
                for (const letter of row) {
                    const key = document.createElement('button');
                    key.className = 'key';
                    key.textContent = letter;
                    key.onclick = () => guessLetter(letter);
                    
                    if (gameState.myGuessedLetters.has(letter)) {
                        key.classList.add('used');
                        key.disabled = true;
                    }
                    
                    rowDiv.appendChild(key);
                }
                
                keyboard.appendChild(rowDiv);
            });
        }

        function setupSolveInput() {
            const container = document.getElementById('solve-input');
            container.innerHTML = '';
            
            for (let i = 0; i < 5; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'solve-letter';
                input.maxLength = 1;
                
                // Pre-fill revealed letters
                if (gameState.myRevealed[i]) {
                    input.value = gameState.opponentWord[i];
                    input.disabled = true;
                }
                
                input.addEventListener('input', (e) => {
                    const value = e.target.value.toUpperCase();
                    if (/^[A-Z]$/.test(value)) {
                        e.target.value = value;
                        const inputs = container.querySelectorAll('.solve-letter');
                        // Find next empty input
                        for (let j = i + 1; j < 5; j++) {
                            if (!inputs[j].disabled && !inputs[j].value) {
                                inputs[j].focus();
                                break;
                            }
                        }
                    } else {
                        e.target.value = '';
                    }
                });

                container.appendChild(input);
            }
        }

        function showGuessMode() {
            document.getElementById('action-buttons').style.display = 'none';
            document.getElementById('keyboard').classList.add('active');
            document.getElementById('solve-section').classList.remove('active');
        }

        function showSolveMode() {
            document.getElementById('action-buttons').style.display = 'none';
            document.getElementById('keyboard').classList.remove('active');
            document.getElementById('solve-section').classList.add('active');
            setupSolveInput();
            
            // Focus first empty input
            const inputs = document.querySelectorAll('#solve-input .solve-letter');
            for (const input of inputs) {
                if (!input.disabled && !input.value) {
                    input.focus();
                    break;
                }
            }
        }

        function cancelSolve() {
            document.getElementById('solve-section').classList.remove('active');
            document.getElementById('action-buttons').style.display = 'flex';
        }

        function guessLetter(letter) {
            if (!gameState.isMyTurn) return;
            
            gameState.myGuessedLetters.add(letter);
            
            // Check if letter is in opponent's word
            let found = false;
            for (let i = 0; i < 5; i++) {
                if (gameState.opponentWord[i] === letter && !gameState.myRevealed[i]) {
                    gameState.myRevealed[i] = true;
                    found = true;
                }
            }
            
            if (found) {
                showMessage(`Found "${letter}"!`, 'success');
                SoundManager.letterFound();
            } else {
                showMessage(`No "${letter}" found`, 'error');
                SoundManager.letterMiss();
            }
            
            // Update UI
            setupBattleUI();
            
            // End turn
            endTurn();
        }

        function attemptSolve() {
            if (!gameState.isMyTurn) return;
            
            // Prevent double submission
            if (gameState.processingGuess) return;
            
            const inputs = document.querySelectorAll('#solve-input .solve-letter');
            let guess = '';
            inputs.forEach(input => guess += input.value.toUpperCase());
            
            if (guess.length !== 5) {
                showMessage('Enter all 5 letters', 'error');
                return;
            }
            
            if (guess === gameState.opponentWord) {
                // Correct!
                showMessage('Correct! You solved it!', 'success');
                SoundManager.solveCorrect();
                handleRoundWin();
            } else {
                // Wrong - lose the round!
                // Show the correct word and give time to read it
                gameState.processingGuess = true;
                showMessage(`Wrong! The word was ${gameState.opponentWord}`, 'error', 4000);
                SoundManager.solveWrong();
                
                // Delay the round loss transition so they can see the message
                setTimeout(() => {
                    gameState.processingGuess = false;
                    handleRoundLoss();
                }, 3000);
            }
        }

        function endTurn() {
            gameState.isMyTurn = false;
            
            // Pass & Play mode - pass to other player
            if (passPlayState.active) {
                passToOtherPlayer();
                return;
            }
            
            // Show waiting phase BEFORE Firebase update
            // (prevents race condition if opponent responds very quickly)
            showPhase('phase-waiting-turn');
            
            if (isFirebaseReady && gameRef) {
                // Update Firebase with our revealed state
                gameRef.child(gameState.myRole).update({
                    revealed: gameState.myRevealed,
                    guessedLetters: Array.from(gameState.myGuessedLetters)
                });
                
                // Switch turn
                const nextTurn = gameState.myRole === 'red' ? 'blue' : 'red';
                gameRef.child('currentTurn').set(nextTurn);
            }
            
            // Demo mode: simulate opponent turn
            if (!isFirebaseReady && !passPlayState.active) {
                setTimeout(() => {
                    // Simulate opponent action
                    gameState.isMyTurn = true;
                    showPhase('phase-battle');
                    updateBattleStatus();
                }, 2000);
            }
        }

        function handleRoundWin() {
            gameState.myWins++;
            
            console.log('=== ROUND WIN ===');
            console.log('My role:', gameState.myRole);
            console.log('My wins:', gameState.myWins);
            
            if (isFirebaseReady && gameRef && !passPlayState.active) {
                gameRef.child(gameState.myRole + '/wins').set(gameState.myWins);
                
                if (gameState.myWins >= 2) {
                    gameState.status = 'finished'; // Match over
                    gameRef.child('status').set('finished');
                } else {
                    gameState.status = 'round_over'; // Prevent handleRoundOver from re-processing
                    gameRef.child('status').set('round_over');
                }
            } else {
                // Pass & Play or demo mode - update local status
                if (gameState.myWins >= 2) {
                    gameState.status = 'finished';
                } else {
                    gameState.status = 'round_over';
                }
            }
            
            // Update scoreboard
            const winsEl = document.getElementById(gameState.myRole + '-wins');
            if (winsEl) {
                winsEl.textContent = gameState.myWins;
                console.log('Updated scoreboard:', gameState.myRole, '-wins to', gameState.myWins);
            }
            
            if (gameState.myWins >= 2) {
                // Match won!
                handleMatchWin();
            } else {
                // Show round result
                showRoundResult(true);
            }
        }

        function handleRoundLoss() {
            // Opponent wins this round because we guessed wrong
            gameState.opponentWins++;
            
            const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
            
            console.log('=== ROUND LOSS ===');
            console.log('My role:', gameState.myRole, 'Opponent:', opponent);
            console.log('Opponent wins:', gameState.opponentWins);
            
            if (isFirebaseReady && gameRef && !passPlayState.active) {
                gameRef.child(opponent + '/wins').set(gameState.opponentWins);
                
                if (gameState.opponentWins >= 2) {
                    gameState.status = 'finished'; // Match over
                    gameRef.child('status').set('finished');
                } else {
                    gameState.status = 'round_over';
                    gameRef.child('status').set('round_over');
                }
            } else {
                // Pass & Play or demo mode - update local status
                if (gameState.opponentWins >= 2) {
                    gameState.status = 'finished';
                } else {
                    gameState.status = 'round_over';
                }
            }
            
            // Update scoreboard
            const winsEl = document.getElementById(opponent + '-wins');
            if (winsEl) {
                winsEl.textContent = gameState.opponentWins;
                console.log('Updated scoreboard:', opponent, '-wins to', gameState.opponentWins);
            }
            
            if (gameState.opponentWins >= 2) {
                // Match lost!
                handleMatchLoss();
            } else {
                // Show round result (we lost)
                showRoundResult(false);
            }
        }

        function showRoundResult(iWon) {
            // Play round result sound
            if (iWon) {
                SoundManager.roundWin();
            } else {
                SoundManager.roundLose();
            }

            const winnerColor = iWon ? gameState.myRole : (gameState.myRole === 'red' ? 'blue' : 'red');
            document.getElementById('round-winner-title').textContent = `ðŸŽ‰ ${winnerColor.charAt(0).toUpperCase() + winnerColor.slice(1)} wins the round!`;
            document.getElementById('round-winner-title').style.color = winnerColor === 'red' ? 'var(--red-corner)' : 'var(--blue-corner)';

            // In pass & play, show both words clearly
            if (passPlayState.active) {
                document.getElementById('reveal-your-word').textContent = `Red: ${passPlayState.redWord}`;
                document.getElementById('reveal-their-word').textContent = `Blue: ${passPlayState.blueWord}`;
            } else {
                document.getElementById('reveal-your-word').textContent = gameState.myWord;
                document.getElementById('reveal-their-word').textContent = gameState.opponentWord;
            }

            // Hide forfeit button initially, show after 15 seconds as escape hatch
            const forfeitBtn = document.getElementById('round-result-forfeit');
            if (forfeitBtn) {
                forfeitBtn.style.display = 'none';
                setTimeout(() => {
                    // Only show if still on round result phase
                    const roundResultPhase = document.getElementById('phase-round-result');
                    if (roundResultPhase && roundResultPhase.classList.contains('active')) {
                        forfeitBtn.style.display = 'block';
                        document.getElementById('round-result-status').textContent = 'Opponent not responding...';
                    }
                }, 15000);
            }

            showPhase('phase-round-result');
            
            // Set flag to prevent immediate round transition
            gameState.showingRoundResult = true;
            
            // Auto advance after delay (5 seconds for better readability)
            if (passPlayState.active) {
                // Pass & play: just advance after delay
                setTimeout(() => {
                    gameState.showingRoundResult = false;
                    nextRound();
                }, 5000);
            } else if (isFirebaseReady && gameRef) {
                // Firebase multiplayer: wait a bit then signal ready
                // This ensures the result is shown for at least 4 seconds
                setTimeout(() => {
                    console.log('Signaling ready for next round...');
                    gameState.showingRoundResult = false;
                    gameRef.child(gameState.myRole).child('readyForNextRound').set(true);
                }, 4000);
            } else {
                // Demo mode: advance after delay
                setTimeout(() => {
                    gameState.showingRoundResult = false;
                    nextRound();
                }, 5000);
            }
        }

        function handleMatchWin() {
            // Stop the sync check
            stopBattleSyncCheck();

            // Play victory bells! (celebratory bell ringing)
            SoundManager.victoryBells();

            // Report to Game Shelf
            reportToGameShelf(true, gameState.myWins, gameState.opponentWins);

            const title = document.getElementById('champion-title');
            title.textContent = `${gameState.myRole === 'red' ? 'Red' : 'Blue'} Corner Wins!`;
            title.className = `champion-title ${gameState.myRole}`;
            
            // Show final words
            document.getElementById('final-words-container').style.display = 'block';
            document.getElementById('final-your-word').textContent = gameState.myWord || '-----';
            document.getElementById('final-their-word').textContent = gameState.opponentWord || '-----';
            
            if (passPlayState.active) {
                // Show red vs blue score
                const redWins = gameState.myRole === 'red' ? gameState.myWins : gameState.opponentWins;
                const blueWins = gameState.myRole === 'blue' ? gameState.myWins : gameState.opponentWins;
                document.getElementById('final-score').textContent = `Red ${redWins} - ${blueWins} Blue`;
                document.getElementById('rating-change-container').style.display = 'none';
            } else {
                document.getElementById('final-score').textContent = `${gameState.myWins} - ${gameState.opponentWins}`;
                
                // Record rated match result (I won) and show rating change
                if (gameState.isRatedGame && currentUser) {
                    const oldRating = userProfile.rating;
                    recordMatchResult(
                        gameState.opponentUserId,
                        gameState.opponentDisplayName,
                        gameState.opponentUserRating,
                        true, // won
                        `${gameState.myWins}-${gameState.opponentWins}`
                    );
                    const newRating = userProfile.rating;
                    const change = newRating - oldRating;
                    const changeText = change >= 0 ? `+${change}` : `${change}`;
                    const changeColor = change >= 0 ? '#4ade80' : '#f87171';
                    document.getElementById('rating-change-text').innerHTML = 
                        `Rating: ${oldRating} â†’ ${newRating} (<span style="color: ${changeColor}">${changeText}</span>)`;
                    document.getElementById('rating-change-container').style.display = 'block';
                } else {
                    document.getElementById('rating-change-container').style.display = 'none';
                }
            }
            
            // Reset match result UI for fresh state
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            document.getElementById('rematch-btn').textContent = 'Rematch';
            
            showPhase('phase-match-result');
            updateAddFriendButton();
        }

        function handleMatchLoss() {
            // Stop the sync check
            stopBattleSyncCheck();

            // Play loss sound
            SoundManager.matchLose();

            // Report to Game Shelf
            reportToGameShelf(false, gameState.myWins, gameState.opponentWins);

            // Called when opponent wins the match
            const title = document.getElementById('champion-title');
            const winner = gameState.myRole === 'red' ? 'Blue' : 'Red';
            title.textContent = `${winner} Corner Wins!`;
            title.className = `champion-title ${gameState.myRole === 'red' ? 'blue' : 'red'}`;
            
            // Show final words
            document.getElementById('final-words-container').style.display = 'block';
            document.getElementById('final-your-word').textContent = gameState.myWord || '-----';
            document.getElementById('final-their-word').textContent = gameState.opponentWord || '-----';
            
            document.getElementById('final-score').textContent = `${gameState.myWins} - ${gameState.opponentWins}`;
            
            // Record rated match result (I lost) and show rating change
            if (gameState.isRatedGame && currentUser && !passPlayState.active) {
                const oldRating = userProfile.rating;
                recordMatchResult(
                    gameState.opponentUserId,
                    gameState.opponentDisplayName,
                    gameState.opponentUserRating,
                    false, // lost
                    `${gameState.myWins}-${gameState.opponentWins}`
                );
                const newRating = userProfile.rating;
                const change = newRating - oldRating;
                const changeText = change >= 0 ? `+${change}` : `${change}`;
                const changeColor = change >= 0 ? '#4ade80' : '#f87171';
                document.getElementById('rating-change-text').innerHTML = 
                    `Rating: ${oldRating} â†’ ${newRating} (<span style="color: ${changeColor}">${changeText}</span>)`;
                document.getElementById('rating-change-container').style.display = 'block';
            } else {
                document.getElementById('rating-change-container').style.display = 'none';
            }
            
            // Reset match result UI for fresh state
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            document.getElementById('rematch-btn').textContent = 'Rematch';
            
            showPhase('phase-match-result');
            updateAddFriendButton();
        }

        // ============ FORFEIT SYSTEM ============
        
        function confirmForfeit() {
            // No forfeiting in Pass & Play mode
            if (passPlayState.active) {
                showMessage('Cannot forfeit in Pass & Play mode', 'error');
                return;
            }
            
            // Check if any moves have been made (penalty applies after first move)
            const movesStarted = gameState.myGuessedLetters.size > 0 || 
                                 gameState.myRevealed.some(r => r) ||
                                 gameState.round > 1;
            
            const penaltyWarning = document.getElementById('forfeit-penalty-warning');
            penaltyWarning.style.display = movesStarted ? 'block' : 'none';
            
            document.getElementById('forfeit-modal').classList.add('active');
        }
        
        function closeForfeitModal(event) {
            if (event.target === event.currentTarget) {
                closeForfeit();
            }
        }
        
        function closeForfeit() {
            document.getElementById('forfeit-modal').classList.remove('active');
        }
        
        async function executeForfeit() {
            closeForfeit();
            
            // Check if moves were made for penalty
            const movesStarted = gameState.myGuessedLetters.size > 0 || 
                                 gameState.myRevealed.some(r => r) ||
                                 gameState.round > 1;
            
            // Update Firebase with forfeit status
            if (isFirebaseReady && gameRef) {
                await gameRef.update({
                    status: 'finished',
                    forfeitedBy: gameState.myRole,
                    [`${gameState.myRole}/wins`]: 0,
                    [`${gameState.myRole === 'red' ? 'blue' : 'red'}/wins`]: 2
                });
            }
            
            // Mark game as finished to prevent duplicate handling
            gameState.status = 'finished';
            
            // Record the loss with potential penalty
            if (gameState.isRatedGame && currentUser && !passPlayState.active) {
                await recordForfeitResult(movesStarted);
            }
            
            // Show forfeit result
            showForfeitResult();
        }
        
        async function recordForfeitResult(withPenalty) {
            if (!currentUser || passPlayState.active) return;
            
            const oldRating = userProfile.rating;
            let newRating = calculateNewRating(oldRating, gameState.opponentUserRating, false, userProfile.gamesPlayed);
            
            // Apply additional forfeit penalty if moves were started
            const FORFEIT_PENALTY = 25;
            if (withPenalty) {
                newRating = Math.max(100, newRating - FORFEIT_PENALTY); // Don't go below 100
            }
            
            const ratingChange = newRating - oldRating;
            
            // Update profile
            userProfile.rating = newRating;
            userProfile.gamesPlayed++;
            userProfile.losses++;
            userProfile.winStreak = 0;
            
            // Add to match history
            userProfile.matchHistory.unshift({
                odponentId: gameState.opponentUserId,
                opponentName: gameState.opponentDisplayName,
                opponentRating: gameState.opponentUserRating,
                result: 'forfeit',
                score: 'Forfeit',
                ratingChange: ratingChange,
                timestamp: Date.now()
            });
            
            // Keep only last 20 matches
            if (userProfile.matchHistory.length > 20) {
                userProfile.matchHistory = userProfile.matchHistory.slice(0, 20);
            }
            
            // Update UI
            document.getElementById('user-rating').textContent = userProfile.rating;
            
            // Save to database
            await saveUserProfile();
            
            // Show rating change
            const penaltyNote = withPenalty ? ' (includes -25 forfeit penalty)' : '';
            showMessage(`Rating: ${oldRating} â†’ ${newRating} (${ratingChange})${penaltyNote}`, 'error');
        }
        
        function showForfeitResult() {
            const title = document.getElementById('champion-title');
            const winner = gameState.myRole === 'red' ? 'Blue' : 'Red';
            title.textContent = `${winner} Wins by Forfeit`;
            title.className = `champion-title ${gameState.myRole === 'red' ? 'blue' : 'red'}`;
            
            document.getElementById('final-score').textContent = 'You forfeited';
            
            // Hide final words for forfeit (not relevant)
            document.getElementById('final-words-container').style.display = 'none';
            
            // Show rating change if this was a rated game
            if (gameState.isRatedGame && currentUser && userProfile.matchHistory.length > 0) {
                const lastMatch = userProfile.matchHistory[0];
                if (lastMatch.result === 'forfeit') {
                    const change = lastMatch.ratingChange;
                    const changeText = change >= 0 ? `+${change}` : `${change}`;
                    const changeColor = change >= 0 ? '#4ade80' : '#f87171';
                    document.getElementById('rating-change-text').innerHTML = 
                        `Rating: ${userProfile.rating - change} â†’ ${userProfile.rating} (<span style="color: ${changeColor}">${changeText}</span>)`;
                    document.getElementById('rating-change-container').style.display = 'block';
                }
            } else {
                document.getElementById('rating-change-container').style.display = 'none';
            }
            
            // Reset match result UI
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            document.getElementById('rematch-btn').textContent = 'Rematch';
            
            showPhase('phase-match-result');
            updateAddFriendButton();
        }
        
        function handleOpponentForfeit() {
            // Called when opponent forfeits
            gameState.status = 'finished';
            
            // Record the win and show rating change
            if (gameState.isRatedGame && currentUser && !passPlayState.active) {
                const oldRating = userProfile.rating;
                recordMatchResult(
                    gameState.opponentUserId,
                    gameState.opponentDisplayName,
                    gameState.opponentUserRating,
                    true, // won
                    'Opponent forfeited'
                );
                const newRating = userProfile.rating;
                const change = newRating - oldRating;
                const changeText = change >= 0 ? `+${change}` : `${change}`;
                const changeColor = change >= 0 ? '#4ade80' : '#f87171';
                document.getElementById('rating-change-text').innerHTML = 
                    `Rating: ${oldRating} â†’ ${newRating} (<span style="color: ${changeColor}">${changeText}</span>)`;
                document.getElementById('rating-change-container').style.display = 'block';
            } else {
                document.getElementById('rating-change-container').style.display = 'none';
            }
            
            const title = document.getElementById('champion-title');
            title.textContent = `You Win! ðŸ†`;
            title.className = `champion-title ${gameState.myRole}`;
            
            document.getElementById('final-score').textContent = 'Opponent forfeited';
            
            // Hide final words for forfeit (not relevant)
            document.getElementById('final-words-container').style.display = 'none';
            
            // Reset match result UI
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            document.getElementById('rematch-btn').textContent = 'Rematch';
            
            showPhase('phase-match-result');
            updateAddFriendButton();
        }

        function updateBattleFromGame(game) {
            // Update turn
            const newTurn = game.currentTurn;
            const wasMyTurn = gameState.isMyTurn;
            gameState.isMyTurn = newTurn === gameState.myRole;
            
            // Update opponent's progress on our word
            const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
            // (We don't show this to the player, but could update UI if needed)
            
            // Only change phase/UI if turn actually changed
            if (gameState.isMyTurn && !wasMyTurn) {
                // Just became our turn - reset to action buttons
                console.log('Turn changed to me, resetting to action buttons');
                SoundManager.yourTurn();
                cancelSolve();
                document.getElementById('keyboard').classList.remove('active');
                document.getElementById('action-buttons').style.display = 'flex';
                showPhase('phase-battle');
            } else if (!gameState.isMyTurn && wasMyTurn) {
                // Just became opponent's turn
                console.log('Turn changed to opponent');
                showPhase('phase-waiting-turn');
            }
            // If turn didn't change, don't reset the UI - player might be mid-action
            
            updateBattleStatus();
        }

        function handleRoundOver(game) {
            // Stop the sync check
            stopBattleSyncCheck();
            
            // Prevent being called multiple times for the same round
            if (gameState.status === 'round_over') {
                console.log('Already in round_over, skipping...');
                return;
            }
            gameState.status = 'round_over';
            
            console.log('=== ROUND OVER ===');
            const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
            const myWinsFromGame = game[gameState.myRole].wins || 0;
            const opponentWinsFromGame = game[opponent].wins || 0;
            
            // Determine if I won this round by comparing with what we had before
            // If my wins increased, I won. If opponent's wins increased, they won.
            const iWon = myWinsFromGame > gameState.myWins;
            
            // Update local state
            gameState.myWins = myWinsFromGame;
            gameState.opponentWins = opponentWinsFromGame;
            
            console.log('My wins:', gameState.myWins, 'Opponent wins:', gameState.opponentWins, 'I won:', iWon);
            
            // Update scoreboard UI (CRITICAL - this was missing for the receiving player!)
            const myWinsEl = document.getElementById(gameState.myRole + '-wins');
            const oppWinsEl = document.getElementById(opponent + '-wins');
            if (myWinsEl) myWinsEl.textContent = gameState.myWins;
            if (oppWinsEl) oppWinsEl.textContent = gameState.opponentWins;
            console.log('Updated scoreboard:', gameState.myRole, '=', gameState.myWins, opponent, '=', gameState.opponentWins);
            
            showRoundResult(iWon);
        }

        function handleMatchOver(game) {
            // Stop the sync check
            stopBattleSyncCheck();
            
            // Prevent duplicate processing (winner already handled via handleMatchWin)
            if (gameState.status === 'finished') {
                console.log('Match already processed, skipping handleMatchOver');
                return;
            }
            gameState.status = 'finished';
            
            const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
            gameState.myWins = game[gameState.myRole].wins || 0;
            gameState.opponentWins = game[opponent].wins || 0;
            
            const iWon = gameState.myWins >= 2;
            
            // Show final words
            document.getElementById('final-words-container').style.display = 'block';
            document.getElementById('final-your-word').textContent = gameState.myWord || '-----';
            document.getElementById('final-their-word').textContent = gameState.opponentWord || '-----';
            
            // Record rated match result and show rating change
            if (gameState.isRatedGame && currentUser && !passPlayState.active) {
                const oldRating = userProfile.rating;
                recordMatchResult(
                    gameState.opponentUserId,
                    gameState.opponentDisplayName,
                    gameState.opponentUserRating,
                    iWon,
                    `${gameState.myWins}-${gameState.opponentWins}`
                );
                const newRating = userProfile.rating;
                const change = newRating - oldRating;
                const changeText = change >= 0 ? `+${change}` : `${change}`;
                const changeColor = change >= 0 ? '#4ade80' : '#f87171';
                document.getElementById('rating-change-text').innerHTML = 
                    `Rating: ${oldRating} â†’ ${newRating} (<span style="color: ${changeColor}">${changeText}</span>)`;
                document.getElementById('rating-change-container').style.display = 'block';
            } else {
                document.getElementById('rating-change-container').style.display = 'none';
            }
            
            const title = document.getElementById('champion-title');
            title.textContent = iWon ? 'You Win! ðŸ†' : 'You Lose ðŸ˜”';
            title.className = iWon ? `champion-title ${gameState.myRole}` : 'champion-title';
            document.getElementById('final-score').textContent = `${gameState.myWins} - ${gameState.opponentWins}`;
            
            // Reset match result UI for fresh state
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            document.getElementById('rematch-btn').textContent = 'Rematch';
            
            showPhase('phase-match-result');
            updateAddFriendButton();
        }

        function nextRound() {
            gameState.round++;
            gameState.myRevealed = [false, false, false, false, false];
            gameState.opponentRevealed = [false, false, false, false, false];
            gameState.myGuessedLetters = new Set();
            
            // Reset battle UI for new round
            resetBattleUI();
            
            // Reset pass & play state for new round
            if (passPlayState.active) {
                passPlayState.redRevealed = [false, false, false, false, false];
                passPlayState.blueRevealed = [false, false, false, false, false];
                passPlayState.redGuessedLetters = new Set();
                passPlayState.blueGuessedLetters = new Set();
            }
            
            document.getElementById('round-number').textContent = gameState.round;
            
            if (gameState.mode === 'advanced') {
                // Load pre-planned words for this round
                if (passPlayState.active) {
                    passPlayState.redWord = passPlayState.redPlannedWords[gameState.round - 1];
                    passPlayState.blueWord = passPlayState.bluePlannedWords[gameState.round - 1];
                    const redScore = calculateWordScore(passPlayState.redWord);
                    const blueScore = calculateWordScore(passPlayState.blueWord);
                    gameState.currentTurn = redScore <= blueScore ? 'red' : 'blue';
                    gameState.status = 'battle';
                    showPhase(`phase-pass-${gameState.currentTurn}`);
                } else {
                    gameState.myWord = gameState.myPlannedWords[gameState.round - 1];
                    gameState.opponentWord = gameState.opponentPlannedWords[gameState.round - 1];
                    gameState.myScore = calculateWordScore(gameState.myWord);
                    gameState.opponentScore = calculateWordScore(gameState.opponentWord);
                    
                    // Determine who goes first
                    gameState.currentTurn = gameState.myScore <= gameState.opponentScore ? gameState.myRole : (gameState.myRole === 'red' ? 'blue' : 'red');
                    gameState.isMyTurn = gameState.currentTurn === gameState.myRole;
                    gameState.status = 'battle';
                    
                    startBattle();
                }
            } else {
                // Beginner mode - enter new word each round
                gameState.myWord = '';
                gameState.opponentWord = '';
                gameState.status = 'setup';
                
                if (passPlayState.active) {
                    passPlayState.redWord = '';
                    passPlayState.blueWord = '';
                    // Red enters word first
                    showPhase('phase-pass-red');
                } else {
                    startWordInput();
                }
            }
        }

        function cancelRematchRequest() {
            if (isFirebaseReady && gameRef) {
                console.log('Cancelling rematch request...');
                gameRef.child(gameState.myRole).child('wantsRematch').set(false);

                // Show buttons again
                document.getElementById('match-result-buttons').style.display = 'block';
                document.getElementById('match-result-waiting').style.display = 'none';

                // Reset button text
                const rematchBtn = document.getElementById('rematch-btn');
                if (rematchBtn) {
                    rematchBtn.textContent = 'Rematch';
                    rematchBtn.classList.remove('pulse-glow');
                }

                showMessage('Rematch cancelled', 'info');
            }
        }

        function requestRematch() {
            // Pass & Play mode - just start rematch immediately
            if (passPlayState.active) {
                startRematch();
                return;
            }

            // Firebase multiplayer - need both players to agree
            if (isFirebaseReady && gameRef) {
                console.log('Requesting rematch...');
                gameRef.child(gameState.myRole).child('wantsRematch').set(true);
                SoundManager.click();
                
                // Show waiting state
                document.getElementById('match-result-buttons').style.display = 'none';
                document.getElementById('match-result-waiting').style.display = 'block';
                document.getElementById('rematch-waiting-text').textContent = 'Waiting for opponent...';
            } else {
                // Demo mode - just start rematch
                startRematch();
            }
        }

        function startRematch() {
            console.log('=== STARTING REMATCH ===');
            console.log('My role:', gameState.myRole);

            // Play sound
            SoundManager.opponentJoined();

            // Reset rematch UI state
            gameState.rematchNotified = false;
            const rematchNotice = document.getElementById('rematch-notice');
            if (rematchNotice) rematchNotice.style.display = 'none';
            const rematchBtn = document.getElementById('rematch-btn');
            if (rematchBtn) {
                rematchBtn.textContent = 'Rematch';
                rematchBtn.classList.remove('pulse-glow');
            }

            // Reset for new match
            gameState.round = 1;
            gameState.myWins = 0;
            gameState.opponentWins = 0;
            gameState.myWord = '';
            gameState.opponentWord = '';
            gameState.myRevealed = [false, false, false, false, false];
            gameState.opponentRevealed = [false, false, false, false, false];
            gameState.myGuessedLetters = new Set();
            gameState.myPlannedWords = ['', '', ''];
            gameState.opponentPlannedWords = ['', '', ''];
            gameState.processingGuess = false;
            gameState.showingRoundResult = false;
            gameState.submittingPlan = false;
            
            // For Blue, set status to 'waiting_rematch' so they can receive word input trigger
            // For Red, set to 'setup' since they'll pick mode
            if (gameState.myRole === 'blue') {
                gameState.status = 'waiting_rematch';
                console.log('Blue waiting for Red to select mode');
            } else {
                gameState.status = 'setup';
            }
            
            // Reset battle UI
            resetBattleUI();
            
            // Reset match result UI for next time
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            
            document.getElementById('round-number').textContent = '1';
            document.getElementById('red-wins').textContent = '0';
            document.getElementById('blue-wins').textContent = '0';
            
            // Reset pass & play state
            if (passPlayState.active) {
                passPlayState.redWord = '';
                passPlayState.blueWord = '';
                passPlayState.redPlannedWords = ['', '', ''];
                passPlayState.bluePlannedWords = ['', '', ''];
                passPlayState.redRevealed = [false, false, false, false, false];
                passPlayState.blueRevealed = [false, false, false, false, false];
                passPlayState.redGuessedLetters = new Set();
                passPlayState.blueGuessedLetters = new Set();
                
                // Red chooses mode
                gameState.myRole = 'red';
                passPlayState.currentPlayer = 'red';
                showModeSelectOrDefault();
                return;
            }
            
            if (isFirebaseReady && gameRef) {
                // Reset game in Firebase (only red does this to avoid race)
                if (gameState.myRole === 'red') {
                    gameRef.update({
                        status: 'rematch_starting',
                        round: 1,
                        currentTurn: null
                    });
                    gameRef.child('red').update({
                        word: '', score: 0, wins: 0,
                        revealed: [false, false, false, false, false],
                        guessedLetters: [], ready: false,
                        plannedWords: ['', '', ''],
                        wantsRematch: null,
                        readyForNextRound: null
                    });
                    gameRef.child('blue').update({
                        word: '', score: 0, wins: 0,
                        revealed: [false, false, false, false, false],
                        guessedLetters: [], ready: false,
                        plannedWords: ['', '', ''],
                        wantsRematch: null,
                        readyForNextRound: null
                    });
                    
                    // Red picks mode again
                    showModeSelectOrDefault();
                }
            } else {
                // Demo mode
                if (gameState.mode === 'advanced') {
                    startWordPlanning();
                } else {
                    startWordInput();
                }
            }
        }

        // Keep old rematch name for backwards compatibility
        function rematch() {
            requestRematch();
        }

        // ============ SHARE RESULTS ============

        // Report game result to Game Shelf
        function reportToGameShelf(won, myWins, oppWins) {
            // Get stats for streak
            const stats = JSON.parse(localStorage.getItem('wordBoxingStats') || '{}');
            
            // Generate grid
            const grid = 'ðŸŸ©'.repeat(myWins) + 'ðŸŸ¥'.repeat(oppWins) + 'â¬œ'.repeat(3 - myWins - oppWins);
            
            // Result emoji
            const resultEmoji = won ? 'ðŸ†' : 'ðŸ˜¤';
            
            // Mode
            const modeEmoji = gameState.mode === 'advanced' ? 'ðŸŽ¯' : 'ðŸ‘¶';
            const modeLabel = gameState.mode === 'advanced' ? 'Advanced' : 'Beginner';
            
            // Score line
            const scoreLine = won ? `Victory ${myWins}-${oppWins}` : `Defeat ${myWins}-${oppWins}`;
            
            // Mode line with streak
            let modeLine = `${modeEmoji} ${modeLabel}`;
            if (stats.winStreak > 1) {
                modeLine += ` Â· ðŸ”¥${stats.winStreak}`;
            }
            
            // Build share text
            const shareText = `ðŸ¥Š Word Boxing ${resultEmoji}
${grid}
${scoreLine}
${modeLine}
wordboxing.com`;
            
            GameShelfIntegration.reportComplete({
                puzzleId: gameState.gameCode || Date.now().toString(),
                won: won,
                score: myWins,
                perfect: won && oppWins === 0,
                mode: gameState.mode,
                streak: {
                    current: stats.winStreak || 0,
                    max: stats.maxWinStreak || 0
                },
                grid: grid,
                scoreLine: scoreLine,
                shareText: shareText,
                meta: {
                    opponent: gameState.opponentDisplayName,
                    matchType: passPlayState.active ? 'local' : 'online',
                    isRated: gameState.isRatedGame
                }
            });
        }

        function shareResults() {
            const iWon = gameState.myWins >= 2;
            const myScore = gameState.myWins;
            const oppScore = gameState.opponentWins;
            
            // Get stats for streak
            const stats = JSON.parse(localStorage.getItem('wordBoxingStats') || '{}');

            // Generate grid
            const grid = 'ðŸŸ©'.repeat(myScore) + 'ðŸŸ¥'.repeat(oppScore) + 'â¬œ'.repeat(3 - myScore - oppScore);

            // Result emoji
            const resultEmoji = iWon ? 'ðŸ†' : 'ðŸ˜¤';

            // Mode
            const modeEmoji = gameState.mode === 'advanced' ? 'ðŸŽ¯' : 'ðŸ‘¶';
            const modeLabel = gameState.mode === 'advanced' ? 'Advanced' : 'Beginner';

            // Score line
            const scoreLine = iWon ? `Victory ${myScore}-${oppScore}` : `Defeat ${myScore}-${oppScore}`;

            // Mode line with streak
            let modeLine = `${modeEmoji} ${modeLabel}`;
            if (stats.winStreak > 1) {
                modeLine += ` Â· ðŸ”¥${stats.winStreak}`;
            }

            // Build standardized share text
            const shareText = `ðŸ¥Š Word Boxing ${resultEmoji}
${grid}
${scoreLine}
${modeLine}
wordboxing.com`;

            // Try to use Web Share API first (mobile)
            if (navigator.share) {
                navigator.share({
                    title: 'Word Boxing Result',
                    text: shareText
                }).then(() => {
                    showMessage('Shared!', 'success');
                    SoundManager.click();
                }).catch(err => {
                    // User cancelled or error - fall back to clipboard
                    copyToClipboard(shareText);
                });
            } else {
                // Fall back to clipboard
                copyToClipboard(shareText);
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                showMessage('Copied to clipboard!', 'success');
                SoundManager.click();
            }).catch(err => {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showMessage('Copied to clipboard!', 'success');
                SoundManager.click();
            });
        }

        function exitToLobby() {
            // Stop any sync checks
            stopBattleSyncCheck();
            
            // Signal exit to opponent in Firebase multiplayer
            if (isFirebaseReady && gameRef && !passPlayState.active) {
                gameRef.child(gameState.myRole).child('exited').set(true);
            }
            
            // Reset match result UI
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            
            // Reset battle UI
            resetBattleUI();
            
            // Reset pass & play state
            passPlayState.active = false;
            document.getElementById('connection-status').style.display = 'block';
            cancelGame();
        }

        // ============ THEME TOGGLE ============

        // ============ SOUND EFFECTS SYSTEM ============

        // Attach to window for onclick handlers
        window.SoundManager = {
            audioContext: null,
            enabled: true,
            volume: 0.5,

            // Initialize audio context (must be called after user interaction)
            init() {
                if (this.audioContext) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('SoundManager initialized');
                } catch (e) {
                    console.warn('Web Audio API not supported:', e);
                }
            },

            // Resume audio context if suspended (required by browsers)
            resume() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume();
                }
            },

            // Generate a simple tone
            playTone(frequency, duration, type = 'sine', gainValue = 0.3) {
                if (!this.enabled || !this.audioContext) {
                    return;
                }
                this.resume();

                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(gainValue * this.volume, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            },

            // Play a sequence of tones
            playSequence(notes, interval = 0.1) {
                if (!this.enabled || !this.audioContext) return;
                notes.forEach((note, i) => {
                    setTimeout(() => {
                        this.playTone(note.freq, note.dur || 0.2, note.type || 'sine', note.gain || 0.3);
                    }, i * interval * 1000);
                });
            },

            // ========== Game Sound Effects ==========

            // Button click (short blip)
            click() {
                this.playTone(800, 0.15, 'sine', 0.5);
            },

            // Letter found (happy rising tone)
            letterFound() {
                this.playSequence([
                    { freq: 523, dur: 0.1 }, // C5
                    { freq: 659, dur: 0.15 } // E5
                ], 0.08);
            },

            // Letter not found (low thud)
            letterMiss() {
                this.playTone(200, 0.15, 'triangle', 0.25);
            },

            // Word submitted
            wordSubmit() {
                this.playTone(440, 0.1, 'sine', 0.2);
            },

            // Correct solve (victory fanfare)
            solveCorrect() {
                this.playSequence([
                    { freq: 523, dur: 0.12 }, // C5
                    { freq: 659, dur: 0.12 }, // E5
                    { freq: 784, dur: 0.12 }, // G5
                    { freq: 1047, dur: 0.3 }  // C6
                ], 0.12);
            },

            // Wrong solve (descending fail)
            solveWrong() {
                this.playSequence([
                    { freq: 400, dur: 0.2, type: 'sawtooth', gain: 0.2 },
                    { freq: 300, dur: 0.25, type: 'sawtooth', gain: 0.2 },
                    { freq: 200, dur: 0.3, type: 'sawtooth', gain: 0.15 }
                ], 0.15);
            },

            // Round win (triumphant)
            roundWin() {
                this.playSequence([
                    { freq: 392, dur: 0.15 }, // G4
                    { freq: 523, dur: 0.15 }, // C5
                    { freq: 659, dur: 0.15 }, // E5
                    { freq: 784, dur: 0.25 }  // G5
                ], 0.1);
            },

            // Round lose (sad descend)
            roundLose() {
                this.playSequence([
                    { freq: 392, dur: 0.2 },  // G4
                    { freq: 349, dur: 0.2 },  // F4
                    { freq: 330, dur: 0.25 }, // E4
                    { freq: 262, dur: 0.35 }  // C4
                ], 0.15);
            },

            // Match victory (epic fanfare)
            matchWin() {
                this.playSequence([
                    { freq: 523, dur: 0.12 }, // C5
                    { freq: 523, dur: 0.12 }, // C5
                    { freq: 523, dur: 0.12 }, // C5
                    { freq: 523, dur: 0.3 },  // C5 (long)
                    { freq: 415, dur: 0.12 }, // Ab4
                    { freq: 466, dur: 0.12 }, // Bb4
                    { freq: 523, dur: 0.4 },  // C5 (long)
                    { freq: 466, dur: 0.08 }, // Bb4
                    { freq: 523, dur: 0.5 }   // C5 (victory!)
                ], 0.12);
            },

            // Match loss
            matchLose() {
                this.playSequence([
                    { freq: 294, dur: 0.3, type: 'triangle' }, // D4
                    { freq: 262, dur: 0.3, type: 'triangle' }, // C4
                    { freq: 220, dur: 0.5, type: 'triangle' }  // A3
                ], 0.25);
            },

            // Turn notification (your turn)
            yourTurn() {
                this.playSequence([
                    { freq: 587, dur: 0.1 }, // D5
                    { freq: 784, dur: 0.15 }  // G5
                ], 0.08);
            },

            // Opponent joined
            opponentJoined() {
                this.playSequence([
                    { freq: 440, dur: 0.1 },  // A4
                    { freq: 554, dur: 0.1 },  // C#5
                    { freq: 659, dur: 0.15 }  // E5
                ], 0.08);
            },

            // Timer warning (if implemented)
            timerWarning() {
                this.playTone(880, 0.08, 'square', 0.15);
            },

            // Boxing bell sound - FM synthesis for realistic metallic bell
            playBell(gainValue = 0.5) {
                if (!this.enabled || !this.audioContext) return;
                this.resume();

                const ctx = this.audioContext;
                const now = ctx.currentTime;
                const duration = 3.5;  // Long ring-out for that vibrating sustain

                // FM synthesis - modulator frequency creates metallic timbre
                const carrierFreq = 660;  // Lower pitch
                const modFreq = 660 * 1.4;  // Inharmonic ratio for metallic sound
                const modIndex = 10;  // Metallic character

                // Carrier oscillator (the sound we hear)
                const carrier = ctx.createOscillator();
                carrier.type = 'sine';
                carrier.frequency.value = carrierFreq;

                // Modulator oscillator (creates the metallic timbre)
                const modulator = ctx.createOscillator();
                modulator.type = 'sine';
                modulator.frequency.value = modFreq;

                // Modulation depth - sustains longer for vibrating ring
                const modGain = ctx.createGain();
                modGain.gain.setValueAtTime(modIndex * modFreq, now);
                modGain.gain.exponentialRampToValueAtTime(modIndex * modFreq * 0.4, now + 1.2);
                modGain.gain.exponentialRampToValueAtTime(modIndex * modFreq * 0.15, now + 2.5);
                modGain.gain.exponentialRampToValueAtTime(1, now + duration);

                // Output envelope - sharp attack, extended vibrating sustain
                const outputGain = ctx.createGain();
                const vol = gainValue * this.volume * 0.3;
                outputGain.gain.setValueAtTime(vol, now);
                outputGain.gain.exponentialRampToValueAtTime(vol * 0.55, now + 0.02);  // Quick initial drop
                outputGain.gain.exponentialRampToValueAtTime(vol * 0.4, now + 0.6);    // Sustain
                outputGain.gain.exponentialRampToValueAtTime(vol * 0.25, now + 1.5);   // Still vibrating
                outputGain.gain.exponentialRampToValueAtTime(vol * 0.1, now + 2.5);    // Slow fade
                outputGain.gain.exponentialRampToValueAtTime(0.001, now + duration);   // Long ring out

                // Connect: modulator -> modGain -> carrier.frequency
                modulator.connect(modGain);
                modGain.connect(carrier.frequency);

                // Carrier -> output
                carrier.connect(outputGain);
                outputGain.connect(ctx.destination);

                // Add a second, slightly detuned bell for chorus/richness
                const carrier2 = ctx.createOscillator();
                carrier2.type = 'sine';
                carrier2.frequency.value = carrierFreq * 1.002;

                const mod2 = ctx.createOscillator();
                mod2.type = 'sine';
                mod2.frequency.value = modFreq * 1.002;

                const modGain2 = ctx.createGain();
                modGain2.gain.setValueAtTime(modIndex * modFreq * 0.9, now);
                modGain2.gain.exponentialRampToValueAtTime(modIndex * modFreq * 0.25, now + 0.5);
                modGain2.gain.exponentialRampToValueAtTime(1, now + duration);

                const outputGain2 = ctx.createGain();
                outputGain2.gain.setValueAtTime(vol * 0.6, now);
                outputGain2.gain.exponentialRampToValueAtTime(vol * 0.3, now + 0.02);
                outputGain2.gain.exponentialRampToValueAtTime(vol * 0.15, now + 0.3);
                outputGain2.gain.exponentialRampToValueAtTime(vol * 0.06, now + 1.0);
                outputGain2.gain.exponentialRampToValueAtTime(0.001, now + duration * 0.9);

                mod2.connect(modGain2);
                modGain2.connect(carrier2.frequency);
                carrier2.connect(outputGain2);
                outputGain2.connect(ctx.destination);

                // Add a third layer - lower octave for body/resonance
                const carrier3 = ctx.createOscillator();
                carrier3.type = 'sine';
                carrier3.frequency.value = carrierFreq * 0.5;  // Octave below

                const mod3 = ctx.createOscillator();
                mod3.type = 'sine';
                mod3.frequency.value = modFreq * 0.5;

                const modGain3 = ctx.createGain();
                modGain3.gain.setValueAtTime(modIndex * modFreq * 0.4, now);
                modGain3.gain.exponentialRampToValueAtTime(1, now + duration * 1.2);

                const outputGain3 = ctx.createGain();
                outputGain3.gain.setValueAtTime(vol * 0.4, now);
                outputGain3.gain.exponentialRampToValueAtTime(vol * 0.25, now + 0.05);
                outputGain3.gain.exponentialRampToValueAtTime(vol * 0.1, now + 0.5);
                outputGain3.gain.exponentialRampToValueAtTime(0.001, now + duration * 1.1);

                mod3.connect(modGain3);
                modGain3.connect(carrier3.frequency);
                carrier3.connect(outputGain3);
                outputGain3.connect(ctx.destination);

                // Start and stop all oscillators
                carrier.start(now);
                modulator.start(now);
                carrier2.start(now);
                mod2.start(now);
                carrier3.start(now);
                mod3.start(now);

                const stopTime = now + duration + 0.2;
                carrier.stop(stopTime);
                modulator.stop(stopTime);
                carrier2.stop(stopTime);
                mod2.stop(stopTime);
                carrier3.stop(stopTime);
                mod3.stop(stopTime);
            },

            // Three bells - boxing match intro (ding ding ding!)
            boxingIntro() {
                if (!this.enabled || !this.audioContext) return;
                // Three quick bells like at the start of a boxing match
                setTimeout(() => this.playBell(0.5), 0);
                setTimeout(() => this.playBell(0.5), 350);
                setTimeout(() => this.playBell(0.5), 700);
            },

            // Single bell - round start
            roundStart() {
                this.playBell(0.6);
            },

            // Victory bells - champion celebration (many bells!)
            victoryBells() {
                if (!this.enabled || !this.audioContext) return;
                // Rapid celebratory bells
                const bellTimes = [0, 200, 400, 700, 900, 1100, 1400, 1700];
                bellTimes.forEach(time => {
                    setTimeout(() => this.playBell(0.4), time);
                });
            },

            // Toggle sound on/off
            toggle() {
                this.enabled = !this.enabled;
                if (this.enabled) {
                    this.click(); // Play confirmation sound
                }
                return this.enabled;
            },

            setEnabled(enabled) {
                this.enabled = enabled;
            },

            setVolume(vol) {
                this.volume = Math.max(0, Math.min(1, vol));
            }
        };

        // Initialize sound on first user interaction and play intro bells
        let introPlayed = false;
        function initSoundAndPlayIntro() {
            SoundManager.init();
            if (!introPlayed && SoundManager.enabled) {
                introPlayed = true;
                // Remove other listeners since we only need one
                document.removeEventListener('click', initSoundAndPlayIntro);
                document.removeEventListener('touchstart', initSoundAndPlayIntro);
                document.removeEventListener('keydown', initSoundAndPlayIntro);
                // Small delay to ensure AudioContext is ready
                setTimeout(() => {
                    SoundManager.boxingIntro();
                }, 100);
            }
        }
        document.addEventListener('click', initSoundAndPlayIntro);
        document.addEventListener('touchstart', initSoundAndPlayIntro);
        document.addEventListener('keydown', initSoundAndPlayIntro);

        // ============ SETTINGS & MENU SYSTEM ============

        let appSettings = {
            darkMode: true,
            showOverview: true,
            defaultMode: 'ask', // 'ask', 'beginner', 'advanced'
            soundEnabled: true,
            soundVolume: 0.5
        };
        
        function loadSettings() {
            const saved = localStorage.getItem('wordboxing-settings');
            if (saved) {
                try {
                    appSettings = { ...appSettings, ...JSON.parse(saved) };
                } catch (e) {
                    console.warn('Failed to load settings:', e);
                }
            }
            
            // Apply settings to UI
            applySettings();
        }
        
        function saveSettings() {
            localStorage.setItem('wordboxing-settings', JSON.stringify(appSettings));
        }
        
        function applySettings() {
            // Apply dark mode
            if (appSettings.darkMode) {
                document.body.removeAttribute('data-theme');
            } else {
                document.body.setAttribute('data-theme', 'light');
            }

            // Apply sound settings
            SoundManager.setEnabled(appSettings.soundEnabled);
            SoundManager.setVolume(appSettings.soundVolume);

            // Update toggle states in settings menu
            const darkModeToggle = document.getElementById('dark-mode-toggle');
            if (darkModeToggle) {
                darkModeToggle.classList.toggle('active', appSettings.darkMode);
            }

            const showOverviewToggle = document.getElementById('show-overview-toggle');
            if (showOverviewToggle) {
                showOverviewToggle.classList.toggle('active', appSettings.showOverview);
            }

            const soundToggle = document.getElementById('sound-toggle');
            if (soundToggle) {
                soundToggle.classList.toggle('active', appSettings.soundEnabled);
            }

            const soundVolumeSlider = document.getElementById('sound-volume');
            if (soundVolumeSlider) {
                soundVolumeSlider.value = appSettings.soundVolume * 100;
            }

            const defaultModeSelect = document.getElementById('default-mode-select');
            if (defaultModeSelect) {
                defaultModeSelect.value = appSettings.defaultMode;
            }
        }

        function toggleSound() {
            appSettings.soundEnabled = !appSettings.soundEnabled;
            SoundManager.setEnabled(appSettings.soundEnabled);
            if (appSettings.soundEnabled) {
                SoundManager.click(); // Play confirmation sound
            }
            applySettings();
            saveSettings();
        }

        function setSoundVolume(value) {
            appSettings.soundVolume = value / 100;
            SoundManager.setVolume(appSettings.soundVolume);
            saveSettings();
        }
        
        // v1.0.9: Test sounds function with mute reminder
        function testSounds() {
            const wasEnabled = SoundManager.enabled;
            SoundManager.setEnabled(true);
            
            // Play letter found sound
            SoundManager.letterFound();
            
            setTimeout(() => {
                // Play letter miss sound
                SoundManager.letterMiss();
                
                setTimeout(() => {
                    // Restore original state
                    SoundManager.setEnabled(wasEnabled);
                    
                    // Show mute reminder (browsers can't detect hardware mute)
                    showMessage('ðŸ”‡ No sound? Check if your device is muted', 'info', 3000);
                }, 400);
            }, 400);
        }
        
        function toggleSettingsMenu() {
            document.getElementById('settings-modal').classList.add('active');
        }
        
        function closeSettingsModal(event) {
            if (event.target === event.currentTarget) {
                closeSettings();
            }
        }
        
        function closeSettings() {
            document.getElementById('settings-modal').classList.remove('active');
        }
        
        function toggleThemeFromMenu() {
            appSettings.darkMode = !appSettings.darkMode;
            applySettings();
            saveSettings();
        }
        
        function toggleShowOverview() {
            appSettings.showOverview = !appSettings.showOverview;
            applySettings();
            saveSettings();
        }
        
        // Plain Mode Functions
        function togglePlainMode() {
            plainMode = !plainMode;
            localStorage.setItem('wordboxingPlainMode', plainMode);
            applyPlainMode();
        }
        
        function initPlainModeToggle() {
            const toggle = document.getElementById('plain-mode-toggle');
            if (toggle) {
                if (plainMode) {
                    toggle.classList.remove('active');
                } else {
                    toggle.classList.add('active');
                }
            }
        }
        
        function applyPlainMode() {
            const toggle = document.getElementById('plain-mode-toggle');
            if (plainMode) {
                document.body.classList.add('plain-mode');
                if (toggle) toggle.classList.remove('active');
            } else {
                document.body.classList.remove('plain-mode');
                if (toggle) toggle.classList.add('active');
            }
        }
        
        function setDefaultMode(mode) {
            appSettings.defaultMode = mode;
            saveSettings();
        }
        
        // Legacy function for compatibility
        function toggleTheme() {
            toggleThemeFromMenu();
        }
        
        function loadSavedTheme() {
            // Now handled by loadSettings
        }
        
        // About Modal
        function showAbout() {
            closeSettings();
            document.getElementById('about-modal').classList.add('active');
        }
        
        function closeAboutModal(event) {
            if (event.target === event.currentTarget) {
                closeAbout();
            }
        }
        
        function closeAbout() {
            document.getElementById('about-modal').classList.remove('active');
        }
        
        // Game Overview Modal
        function showGameOverview() {
            closeSettings();
            document.getElementById('overview-modal').classList.add('active');
        }
        
        function closeOverviewModal(event) {
            if (event.target === event.currentTarget) {
                closeOverview();
            }
        }
        
        function closeOverview() {
            document.getElementById('overview-modal').classList.remove('active');
        }
        
        function updateDontShowOverview(checked) {
            appSettings.showOverview = !checked;
            document.getElementById('show-overview-toggle').classList.toggle('active', !checked);
            saveSettings();
        }
        
        function checkShowOverviewOnStart() {
            // Check if this is first visit or if overview should be shown
            const hasVisited = localStorage.getItem('wordboxing-visited');
            if (!hasVisited && appSettings.showOverview) {
                showGameOverview();
                localStorage.setItem('wordboxing-visited', 'true');
            }
        }
        
        // ============ RECONNECTION & DISCONNECT SYSTEM ============
        
        const DISCONNECT_TIMEOUT = 60000; // 60 seconds before forfeit
        let disconnectCheckInterval = null;
        
        function saveActiveGame() {
            if (gameState.gameCode && gameState.myRole) {
                const activeGame = {
                    gameCode: gameState.gameCode,
                    myRole: gameState.myRole,
                    timestamp: Date.now()
                };
                localStorage.setItem('wordboxing-active-game', JSON.stringify(activeGame));
                console.log('Saved active game:', activeGame);
            }
        }
        
        function clearActiveGame() {
            localStorage.removeItem('wordboxing-active-game');
            console.log('Cleared active game');
        }
        
        function checkForActiveGame() {
            if (!isFirebaseReady) return;
            
            const saved = localStorage.getItem('wordboxing-active-game');
            if (!saved) return;
            
            try {
                const activeGame = JSON.parse(saved);
                const age = Date.now() - activeGame.timestamp;
                
                // Only try to rejoin if less than 10 minutes old
                if (age > 10 * 60 * 1000) {
                    clearActiveGame();
                    return;
                }
                
                console.log('Found active game:', activeGame);
                attemptRejoin(activeGame.gameCode, activeGame.myRole);
            } catch (e) {
                console.warn('Error parsing active game:', e);
                clearActiveGame();
            }
        }
        
        function attemptRejoin(gameCode, myRole) {
            console.log('Attempting to rejoin game:', gameCode, 'as', myRole);

            // Show reconnecting overlay
            showReconnectingOverlay();

            const rejoinRef = db.ref('games/' + gameCode);
            rejoinRef.once('value').then(snapshot => {
                if (!snapshot.exists()) {
                    console.log('Game no longer exists');
                    hideReconnectingOverlay();
                    clearActiveGame();
                    showMessage('Previous game ended', 'info');
                    return;
                }

                const game = snapshot.val();

                // Check if game is finished
                if (game.status === 'finished') {
                    console.log('Game already finished');
                    hideReconnectingOverlay();
                    clearActiveGame();
                    return;
                }

                // Verify we were in this game
                const myData = game[myRole];
                if (!myData || (myData.deviceId !== deviceId && myData.odid !== (currentUser ? currentUser.uid : null))) {
                    console.log('Not our game');
                    hideReconnectingOverlay();
                    clearActiveGame();
                    return;
                }

                // Rejoin the game!
                console.log('Rejoining game!');
                gameState.gameCode = gameCode;
                gameState.myRole = myRole;
                gameState.mode = game.mode || 'beginner';
                gameState.round = game.round || 1;
                gameState.isRatedGame = game.isRated || false;
                
                // Get opponent info
                const opponent = myRole === 'red' ? 'blue' : 'red';
                gameState.opponentUserId = game[opponent].odid;
                gameState.opponentDisplayName = game[opponent].displayName || 'Opponent';
                gameState.opponentUserRating = game[opponent].rating || 1200;
                
                // Set up game ref and listener
                gameRef = rejoinRef;
                gameRef.on('value', handleGameUpdate);
                
                // Mark as connected
                gameRef.child(myRole + '/connected').set(true);
                gameRef.child(myRole + '/connected').onDisconnect().set(false);
                gameRef.child(myRole + '/lastSeen').set(firebase.database.ServerValue.TIMESTAMP);
                
                // Start disconnect monitoring
                startDisconnectMonitoring();

                // Hide reconnecting overlay
                hideReconnectingOverlay();

                showMessage('Reconnected to game!', 'success');
                SoundManager.opponentJoined();

                // Trigger a game update to restore UI state
                handleGameUpdate(snapshot);

            }).catch(err => {
                console.error('Error rejoining:', err);
                hideReconnectingOverlay();
                clearActiveGame();
                showMessage('Failed to reconnect', 'error');
            });
        }

        function showReconnectingOverlay() {
            const overlay = document.getElementById('reconnecting-overlay');
            if (overlay) {
                overlay.classList.add('active');
            }
        }

        function hideReconnectingOverlay() {
            const overlay = document.getElementById('reconnecting-overlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
        }
        
        function startDisconnectMonitoring() {
            if (disconnectCheckInterval) {
                clearInterval(disconnectCheckInterval);
            }
            
            // Update our lastSeen timestamp periodically
            const updateLastSeen = () => {
                if (gameRef && gameState.myRole) {
                    gameRef.child(gameState.myRole + '/lastSeen').set(firebase.database.ServerValue.TIMESTAMP);
                }
            };
            
            // Update every 10 seconds
            disconnectCheckInterval = setInterval(updateLastSeen, 10000);
            updateLastSeen();
        }
        
        function stopDisconnectMonitoring() {
            if (disconnectCheckInterval) {
                clearInterval(disconnectCheckInterval);
                disconnectCheckInterval = null;
            }
        }
        
        function checkOpponentDisconnect(game) {
            if (!game || game.status === 'finished' || passPlayState.active) return;

            const opponent = gameState.myRole === 'red' ? 'blue' : 'red';
            const opponentData = game[opponent];
            const banner = document.getElementById('disconnect-banner');
            const countdown = document.getElementById('disconnect-countdown');

            if (!opponentData) return;

            // Check if opponent is disconnected
            if (opponentData.connected === false && opponentData.lastSeen) {
                const timeSinceLastSeen = Date.now() - opponentData.lastSeen;

                if (timeSinceLastSeen > DISCONNECT_TIMEOUT) {
                    console.log('Opponent disconnected for', timeSinceLastSeen, 'ms - claiming win');
                    hideDisconnectBanner();
                    claimDisconnectWin();
                } else {
                    // Show countdown banner
                    const remaining = Math.ceil((DISCONNECT_TIMEOUT - timeSinceLastSeen) / 1000);
                    if (remaining > 0) {
                        showDisconnectBanner(remaining);
                    }
                }
            } else if (opponentData.connected === true) {
                // Opponent reconnected!
                hideDisconnectBanner();
                if (gameState.opponentWasDisconnected) {
                    showMessage('Opponent reconnected!', 'success');
                    SoundManager.opponentJoined();
                    gameState.opponentWasDisconnected = false;
                }
            }
        }

        function showDisconnectBanner(seconds) {
            const banner = document.getElementById('disconnect-banner');
            const countdown = document.getElementById('disconnect-countdown');
            if (banner && countdown) {
                banner.classList.add('active');
                countdown.textContent = seconds;
                gameState.opponentWasDisconnected = true;
            }
        }

        function hideDisconnectBanner() {
            const banner = document.getElementById('disconnect-banner');
            if (banner) {
                banner.classList.remove('active');
            }
        }
        
        function claimDisconnectWin() {
            if (!gameRef || gameState.status === 'finished') return;
            
            gameState.status = 'finished';
            
            // Update Firebase
            gameRef.update({
                status: 'finished',
                disconnectWinner: gameState.myRole,
                [`${gameState.myRole}/wins`]: 2,
                [`${gameState.myRole === 'red' ? 'blue' : 'red'}/wins`]: 0
            });
            
            // Record the win
            if (gameState.isRatedGame && currentUser && !passPlayState.active) {
                recordMatchResult(
                    gameState.opponentUserId,
                    gameState.opponentDisplayName,
                    gameState.opponentUserRating,
                    true,
                    'Opponent disconnected'
                );
            }
            
            // Show result
            const title = document.getElementById('champion-title');
            title.textContent = 'You Win! ðŸ†';
            title.className = `champion-title ${gameState.myRole}`;
            document.getElementById('final-score').textContent = 'Opponent disconnected';
            
            document.getElementById('match-result-buttons').style.display = 'block';
            document.getElementById('match-result-waiting').style.display = 'none';
            document.getElementById('rematch-btn').style.display = 'none'; // Can't rematch if opponent left
            
            clearActiveGame();
            stopDisconnectMonitoring();
            
            showPhase('phase-match-result');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Word Boxing v1.0.9 - Boxing bell sounds');
            console.log('Device ID:', deviceId);
            console.log('Firebase ready:', isFirebaseReady);

            // Initialize Game Shelf Integration
            GameShelfIntegration.init('wordboxing', {
                name: 'Word Boxing',
                icon: 'ðŸ¥Š',
                url: 'wordboxing.com',
                version: '1.0.9',
                type: 'multiplayer'
            });

            // Load settings
            loadSettings();
            
            // Initialize Plain Mode
            applyPlainMode();
            initPlainModeToggle();

            // Initialize connection monitor
            initConnectionMonitor();

            // Initialize tutorial for first-time players
            TutorialManager.init();

            // Check if we should show the overview
            checkShowOverviewOnStart();

            // Set up auth state listener
            if (auth) {
                auth.onAuthStateChanged(handleAuthStateChange);
            } else {
                // Demo mode - hide sign in, show guest profile
                document.getElementById('sign-in-btn').style.display = 'none';
                const ratedBadge = document.getElementById('create-rated-badge');
                if (ratedBadge) ratedBadge.style.display = 'none';
                // Also update connection status for demo mode
                updateConnectionStatus('disconnected');
            }
            
            // Keyboard support for battle mode
            document.addEventListener('keydown', handleBattleKeypress);
            
            // Check for active game to rejoin (after a short delay for auth to settle)
            setTimeout(() => {
                checkForActiveGame();
            }, 1500);
            
            // Handle page visibility changes
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible' && gameRef && gameState.myRole) {
                    // Refresh connection when returning to page
                    gameRef.child(gameState.myRole + '/connected').set(true);
                    gameRef.child(gameState.myRole + '/lastSeen').set(firebase.database.ServerValue.TIMESTAMP);
                }
            });
        });
        
        function handleBattleKeypress(e) {
            // Only handle if in battle phase and it's my turn
            const battlePhase = document.getElementById('phase-battle');
            if (!battlePhase.classList.contains('active') || !gameState.isMyTurn) {
                return;
            }
            
            const keyboard = document.getElementById('keyboard');
            const solveSection = document.getElementById('solve-section');
            const actionButtons = document.getElementById('action-buttons');
            
            // ESC key - cancel solve mode or go back to action buttons
            if (e.key === 'Escape') {
                if (solveSection.classList.contains('active')) {
                    cancelSolve();
                    e.preventDefault();
                } else if (keyboard.classList.contains('active')) {
                    keyboard.classList.remove('active');
                    actionButtons.style.display = 'flex';
                    e.preventDefault();
                }
                return;
            }
            
            // ENTER key - attempt solve if in solve mode
            if (e.key === 'Enter') {
                if (solveSection.classList.contains('active')) {
                    attemptSolve();
                    e.preventDefault();
                }
                return;
            }
            
            // Letter keys - guess letter if keyboard is active
            if (/^[a-zA-Z]$/.test(e.key)) {
                const letter = e.key.toUpperCase();
                
                // If action buttons are showing, auto-switch to guess mode
                if (actionButtons.style.display !== 'none' && !keyboard.classList.contains('active') && !solveSection.classList.contains('active')) {
                    showGuessMode();
                }
                
                // If keyboard is active, guess the letter
                if (keyboard.classList.contains('active')) {
                    // Check if letter hasn't been guessed yet
                    if (!gameState.myGuessedLetters.has(letter)) {
                        guessLetter(letter);
                        e.preventDefault();
                    } else {
                        showMessage(`Already guessed "${letter}"`, 'error');
                        e.preventDefault();
                    }
                }
                // If solve section is active, let it handle input normally
            }
            
            // G key (with Ctrl) - switch to guess mode
            if (e.key === 'g' && !e.ctrlKey && !e.metaKey && !keyboard.classList.contains('active') && !solveSection.classList.contains('active')) {
                showGuessMode();
                e.preventDefault();
                return;
            }
            
            // S key (with Ctrl) - switch to solve mode  
            if (e.key === 's' && !e.ctrlKey && !e.metaKey && !keyboard.classList.contains('active') && !solveSection.classList.contains('active')) {
                showSolveMode();
                e.preventDefault();
                return;
            }
        }
    </script>
    
    <!-- PWA Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((reg) => {
                        console.log('[WordBoxing] SW registered');
                        setInterval(() => reg.update(), 3600000);
                        reg.addEventListener('updatefound', () => {
                            const nw = reg.installing;
                            nw.addEventListener('statechange', () => {
                                if (nw.state === 'installed' && navigator.serviceWorker.controller) {
                                    if (confirm('New version of Word Boxing available! Reload?')) location.reload();
                                }
                            });
                        });
                    }).catch((e) => console.log('[WordBoxing] SW failed:', e));
            });
        }
        let deferredInstallPrompt = null;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredInstallPrompt = e;
            if (!window.matchMedia('(display-mode: standalone)').matches && !sessionStorage.getItem('wb_prompted')) {
                const b = document.createElement('div');
                b.id = 'pwa-install-banner';
                b.innerHTML = `<div style="position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,#c41e3a,#8b1528);color:#eee;padding:12px 20px;border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,0.3);display:flex;align-items:center;gap:12px;z-index:9999;max-width:90%;border:2px solid #ffd700;font-family:'Oswald',sans-serif;">
                    <span style="font-size:1.5rem;">ðŸ¥Š</span>
                    <div style="flex:1;"><div style="font-weight:600;">Install Word Boxing</div><div style="font-size:0.85rem;opacity:0.9;">Add to home screen</div></div>
                    <button onclick="installPWA()" style="background:#ffd700;color:#12121f;border:none;padding:8px 16px;border-radius:8px;font-weight:600;cursor:pointer;">Install</button>
                    <button onclick="dismissInstall()" style="background:transparent;border:none;color:#eee;font-size:1.2rem;cursor:pointer;opacity:0.7;">âœ•</button>
                </div>`;
                document.body.appendChild(b);
            }
        });
        function installPWA() { if (deferredInstallPrompt) { deferredInstallPrompt.prompt(); deferredInstallPrompt.userChoice.then(() => { deferredInstallPrompt = null; dismissInstall(); }); } }
        function dismissInstall() { const b = document.getElementById('pwa-install-banner'); if (b) b.remove(); sessionStorage.setItem('wb_prompted', 'true'); }
    </script>
</body>
</html>
